import { fileURLToPath } from 'node:url';
import crypto from 'node:crypto';
import { existsSync } from 'node:fs';
import { createJiti } from 'jiti';
import { createRegExp, exactly } from 'magic-regexp';
import { useLogger, defineNuxtModule, resolvePath, addTemplate, addPlugin, isNuxtMajorVersion, addImports, addComponentsDir, addServerHandler } from '@nuxt/kit';
import { colors } from 'consola/utils';
import { resolve, relative, join } from 'pathe';
import { defu } from 'defu';
import { genExport } from 'knitwork';

const name = "@nuxtjs/sanity";
const version = "1.13.3";

const logger = useLogger("@nuxtjs/sanity");
const CONFIG_KEY = "sanity";
const module = defineNuxtModule({
  meta: {
    name,
    version,
    configKey: CONFIG_KEY,
    compatibility: {
      nuxt: "^3.7.0",
      bridge: true
    }
  },
  defaults: {
    additionalClients: {},
    apiVersion: "1",
    disableSmartCdn: false,
    perspective: "raw",
    withCredentials: false,
    configFile: "~~/cms/sanity.config"
  },
  async setup(options, nuxt) {
    if (!options.projectId || !options.dataset) {
      const sanityConfigPath = await resolvePath(options.configFile) || /* backwards compatibility */
      resolve(nuxt.options.rootDir, "./sanity.json");
      const relativeSanityConfigPath = relative(nuxt.options.rootDir, sanityConfigPath);
      if (!relativeSanityConfigPath.startsWith("..")) {
        nuxt.options.watch.push(createRegExp(exactly(relativeSanityConfigPath)));
      }
      const jiti = createJiti(import.meta.url, { jsx: true });
      if (existsSync(sanityConfigPath)) {
        const sanityConfig = await jiti.import(sanityConfigPath, { default: true, try: true });
        if (sanityConfig) {
          options.projectId ||= sanityConfig.projectId;
          options.dataset ||= sanityConfig.dataset;
        }
      }
    }
    options.dataset ||= "production";
    if (options.visualEditing) {
      try {
        if (options.minimal) {
          throw new Error("Minimal client is enabled.");
        }
        if (!options.visualEditing.token) {
          throw new Error(`'token' is required.`);
        }
        if (!options.visualEditing.studioUrl) {
          throw new Error(`'studioUrl' is required.`);
        }
        if (options.apiVersion === "1") {
          throw new Error(`The specified API Version must be ${colors.bold("2021-03-25")} or later.`);
        }
      } catch (e) {
        options.visualEditing = void 0;
        if (e instanceof Error) {
          logger.warn(`Could not enable visual editing: ${e.message}`);
        }
      }
    }
    const visualEditing = options.visualEditing && {
      mode: options.visualEditing.mode || "live-visual-editing",
      previewMode: options.visualEditing.previewMode !== false ? defu(options.visualEditing.previewMode, {
        enable: "/preview/enable",
        disable: "/preview/disable"
      }) : false,
      proxyEndpoint: options.visualEditing.proxyEndpoint || "/_sanity/fetch",
      refresh: options.visualEditing.refresh,
      studioUrl: options.visualEditing.studioUrl || "",
      zIndex: options.visualEditing.zIndex
    };
    nuxt.options.runtimeConfig.sanity = defu(nuxt.options.runtimeConfig.sanity, {
      visualEditing: options.visualEditing && {
        ...visualEditing,
        previewModeId: visualEditing.previewMode ? crypto.randomBytes(16).toString("hex") : "",
        token: options.visualEditing.token || ""
      }
    });
    const { projectId, dataset } = nuxt.options.runtimeConfig.public.sanity = defu(nuxt.options.runtimeConfig.public.sanity, {
      additionalClients: options.additionalClients,
      // has default
      apiVersion: options.apiVersion,
      // has default
      dataset: options.dataset,
      // has default
      disableSmartCdn: options.disableSmartCdn,
      // has default
      perspective: options.perspective,
      // has default
      projectId: options.projectId || "",
      stega: options.visualEditing && options.visualEditing.stega !== false && options.visualEditing.previewMode !== false && {
        enabled: true,
        studioUrl: options.visualEditing.studioUrl
      } || {},
      token: options.token || "",
      useCdn: options.useCdn,
      // enforced
      visualEditing,
      withCredentials: options.withCredentials
      // has default
    });
    if (!projectId) {
      logger.warn(`No Sanity project found. Make sure you specify a ${colors.bold("projectId")} in your Sanity config.`);
    } else {
      logger.info(`Running with Sanity project ${colors.bold(projectId)} (${colors.bold(dataset)}).`);
    }
    const runtimeDir = fileURLToPath(new URL("./runtime", import.meta.url));
    nuxt.options.build.transpile.push(runtimeDir, "@nuxtjs/sanity");
    nuxt.options.build.transpile.push("@sanity/core-loader", "@sanity/preview-url-secret");
    const clientSpecifier = options.minimal ? join(runtimeDir, "minimal-client") : "@sanity/client";
    addTemplate({
      filename: "sanity-client.mjs",
      getContents: () => genExport(clientSpecifier, ["createClient"])
    });
    if (options.globalHelper) {
      addPlugin({ src: join(runtimeDir, "plugins/global-helper") });
      if (isNuxtMajorVersion(2)) {
        nuxt.hook("prepare:types", ({ references }) => {
          references.push({ types: "@nuxtjs/sanity/dist/runtime/plugins/global-helper" });
        });
      }
    }
    const composablesFile = visualEditing ? join(runtimeDir, "composables/visual-editing") : join(runtimeDir, "composables/index");
    addImports([
      { name: "createClient", as: "createSanityClient", from: "#build/sanity-client.mjs" },
      { name: "groq", from: join(runtimeDir, "groq") },
      { name: "useSanity", from: composablesFile },
      { name: "useLazySanityQuery", from: join(runtimeDir, "composables/index") },
      ...isNuxtMajorVersion(3) ? [{ name: "useSanityQuery", from: composablesFile }] : []
    ]);
    const clientPath = await resolvePath(clientSpecifier);
    nuxt.hook("prepare:types", async ({ tsConfig }) => {
      tsConfig.compilerOptions ||= {};
      tsConfig.compilerOptions.paths["#sanity-client"] = [clientPath];
      tsConfig.compilerOptions.paths["#sanity-composables"] = [composablesFile];
    });
    nuxt.hook("nitro:config", (config) => {
      config.typescript = defu(config.typescript, {
        tsConfig: {
          compilerOptions: {
            paths: {
              ["#sanity-client"]: [clientPath],
              ["#sanity-composables"]: [composablesFile]
            }
          }
        }
      });
      if (config.imports === false)
        return;
      config.virtual ||= {};
      config.virtual["#sanity-client"] = genExport(clientSpecifier, ["createClient"]);
      config.externals ||= {};
      config.externals.inline ||= [];
      config.externals.inline.push(runtimeDir);
      config.imports = defu(config.imports, {
        presets: [
          {
            from: "#sanity-client",
            imports: [{ name: "createClient", as: "createSanityClient" }]
          },
          {
            from: join(runtimeDir, "server/utils/index"),
            imports: ["useSanity"]
          },
          {
            from: join(runtimeDir, "groq"),
            imports: ["groq"]
          }
        ]
      });
    });
    await addComponentsDir({
      path: join(runtimeDir, "components"),
      extensions: ["js", "ts", "mjs"]
    });
    if (visualEditing) {
      nuxt.options.build.transpile.push("async-cache-dedupe");
      nuxt.options.vite.resolve = defu(nuxt.options.vite.resolve, {
        dedupe: ["@sanity/client"]
      });
      nuxt.options.vite.optimizeDeps = defu(nuxt.options.vite.optimizeDeps, {
        include: [
          "@nuxtjs/sanity > @sanity/visual-editing > @sanity/visual-editing > react-is",
          "@nuxtjs/sanity > @sanity/visual-editing > @sanity/mutate > lodash/groupBy.js",
          "@nuxtjs/sanity > @sanity/visual-editing > react",
          "@nuxtjs/sanity > @sanity/visual-editing > react/jsx-runtime",
          "@nuxtjs/sanity > @sanity/visual-editing > react-dom",
          "@nuxtjs/sanity > @sanity/visual-editing > react-dom/client",
          "@nuxtjs/sanity > @sanity/visual-editing > react-compiler-runtime",
          "@sanity/client"
        ]
      });
      if (isNuxtMajorVersion(3)) {
        addImports([
          { name: "useSanityLiveMode", from: composablesFile },
          { name: "useSanityVisualEditing", from: composablesFile },
          { name: "useSanityVisualEditingState", from: composablesFile },
          { name: "createDataAttribute", from: "@sanity/visual-editing", as: "createSanityDataAttribute" }
        ]);
      }
      addPlugin({
        mode: "server",
        src: join(runtimeDir, "plugins", "visual-editing.server")
      });
      if (visualEditing.mode !== "custom") {
        addPlugin({
          mode: "client",
          src: join(runtimeDir, "plugins", "visual-editing.client")
        });
        logger.info(`Visual editing enabled globally.`);
      } else {
        logger.info(`Call ${colors.bold("useSanityVisualEditing()")} in your application to enable visual editing.`);
      }
      addServerHandler({
        method: "post",
        route: visualEditing.proxyEndpoint,
        handler: join(runtimeDir, "server/routes/proxy")
      });
      if (visualEditing?.previewMode !== false) {
        addServerHandler({
          method: "get",
          route: visualEditing.previewMode.enable,
          handler: join(runtimeDir, "server/routes/preview/enable")
        });
        addServerHandler({
          method: "get",
          route: visualEditing.previewMode.disable,
          handler: join(runtimeDir, "server/routes/preview/disable")
        });
        logger.info(
          `Preview mode enabled. Added routes at: ${Object.values(visualEditing.previewMode).map((route) => colors.bold(route)).join(", ")}.`
        );
      }
    }
  }
});

export { module as default };
