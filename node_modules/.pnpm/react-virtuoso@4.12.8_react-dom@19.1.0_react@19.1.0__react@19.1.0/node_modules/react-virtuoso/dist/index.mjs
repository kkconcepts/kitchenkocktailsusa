import { jsx as z, jsxs as Kt, Fragment as so } from "react/jsx-runtime";
import H, { createElement as $t } from "react";
import io from "react-dom";
const we = 0, zt = 1, qt = 2, En = 4;
function ln(t) {
  return () => t;
}
function lo(t) {
  t();
}
function ne(t, e) {
  return (n) => t(e(n));
}
function cn(t, e) {
  return () => t(e);
}
function co(t, e) {
  return (n) => t(e, n);
}
function Me(t) {
  return t !== void 0;
}
function uo(...t) {
  return () => {
    t.map(lo);
  };
}
function Yt() {
}
function ve(t, e) {
  return e(t), t;
}
function ao(t, e) {
  return e(t);
}
function X(...t) {
  return t;
}
function K(t, e) {
  return t(zt, e);
}
function W(t, e) {
  t(we, e);
}
function We(t) {
  t(qt);
}
function st(t) {
  return t(En);
}
function O(t, e) {
  return K(t, co(e, we));
}
function bt(t, e) {
  const n = t(zt, (o) => {
    n(), e(o);
  });
  return n;
}
function un(t) {
  let e, n;
  return (o) => (r) => {
    e = r, n && clearTimeout(n), n = setTimeout(() => {
      o(e);
    }, t);
  };
}
function Bn(t, e) {
  return t === e;
}
function Y(t = Bn) {
  let e;
  return (n) => (o) => {
    t(e, o) || (e = o, n(o));
  };
}
function P(t) {
  return (e) => (n) => {
    t(n) && e(n);
  };
}
function E(t) {
  return (e) => ne(e, t);
}
function yt(t) {
  return (e) => () => {
    e(t);
  };
}
function x(t, ...e) {
  const n = fo(...e);
  return (o, r) => {
    switch (o) {
      case qt:
        We(t);
        return;
      case zt:
        return K(t, n(r));
    }
  };
}
function Rt(t, e) {
  return (n) => (o) => {
    n(e = t(e, o));
  };
}
function jt(t) {
  return (e) => (n) => {
    t > 0 ? t-- : e(n);
  };
}
function Lt(t) {
  let e = null, n;
  return (o) => (r) => {
    e = r, !n && (n = setTimeout(() => {
      n = void 0, o(e);
    }, t));
  };
}
function _(...t) {
  const e = new Array(t.length);
  let n = 0, o = null;
  const r = Math.pow(2, t.length) - 1;
  return t.forEach((s, i) => {
    const l = Math.pow(2, i);
    K(s, (c) => {
      const a = n;
      n = n | l, e[i] = c, a !== r && n === r && o && (o(), o = null);
    });
  }), (s) => (i) => {
    const l = () => {
      s([i].concat(e));
    };
    n === r ? l() : o = l;
  };
}
function fo(...t) {
  return (e) => t.reduceRight(ao, e);
}
function mo(t) {
  let e, n;
  const o = () => e == null ? void 0 : e();
  return function(r, s) {
    switch (r) {
      case zt:
        return s ? n === s ? void 0 : (o(), n = s, e = K(t, s), e) : (o(), Yt);
      case qt:
        o(), n = null;
        return;
    }
  };
}
function v(t) {
  let e = t;
  const n = $();
  return (o, r) => {
    switch (o) {
      case we:
        e = r;
        break;
      case zt: {
        r(e);
        break;
      }
      case En:
        return e;
    }
    return n(o, r);
  };
}
function ct(t, e) {
  return ve(v(e), (n) => O(t, n));
}
function $() {
  const t = [];
  return (e, n) => {
    switch (e) {
      case we:
        t.slice().forEach((o) => {
          o(n);
        });
        return;
      case qt:
        t.splice(0, t.length);
        return;
      case zt:
        return t.push(n), () => {
          const o = t.indexOf(n);
          o > -1 && t.splice(o, 1);
        };
    }
  };
}
function ht(t) {
  return ve($(), (e) => O(t, e));
}
function U(t, e = [], { singleton: n } = { singleton: !0 }) {
  return {
    constructor: t,
    dependencies: e,
    id: po(),
    singleton: n
  };
}
const po = () => Symbol();
function ho(t) {
  const e = /* @__PURE__ */ new Map(), n = ({ constructor: o, dependencies: r, id: s, singleton: i }) => {
    if (i && e.has(s))
      return e.get(s);
    const l = o(r.map((c) => n(c)));
    return i && e.set(s, l), l;
  };
  return n(t);
}
function rt(...t) {
  const e = $(), n = new Array(t.length);
  let o = 0;
  const r = Math.pow(2, t.length) - 1;
  return t.forEach((s, i) => {
    const l = Math.pow(2, i);
    K(s, (c) => {
      n[i] = c, o = o | l, o === r && W(e, n);
    });
  }), function(s, i) {
    switch (s) {
      case qt: {
        We(e);
        return;
      }
      case zt:
        return o === r && i(n), K(e, i);
    }
  };
}
function A(t, e = Bn) {
  return x(t, Y(e));
}
function an(...t) {
  return function(e, n) {
    switch (e) {
      case qt:
        return;
      case zt:
        return uo(...t.map((o) => K(o, n)));
    }
  };
}
var mt = /* @__PURE__ */ ((t) => (t[t.DEBUG = 0] = "DEBUG", t[t.INFO = 1] = "INFO", t[t.WARN = 2] = "WARN", t[t.ERROR = 3] = "ERROR", t))(mt || {});
const go = {
  0: "debug",
  3: "error",
  1: "log",
  2: "warn"
}, Io = () => typeof globalThis > "u" ? window : globalThis, Vt = U(
  () => {
    const t = v(
      3
      /* ERROR */
    );
    return {
      log: v((n, o, r = 1) => {
        var i;
        const s = (i = Io().VIRTUOSO_LOG_LEVEL) != null ? i : st(t);
        r >= s && console[go[r]](
          "%creact-virtuoso: %c%s %o",
          "color: #0253b3; font-weight: bold",
          "color: initial",
          n,
          o
        );
      }),
      logLevel: t
    };
  },
  [],
  { singleton: !0 }
);
function Ht(t, e, n) {
  return Ge(t, e, n).callbackRef;
}
function Ge(t, e, n) {
  const o = H.useRef(null);
  let r = (i) => {
  };
  const s = H.useMemo(() => typeof ResizeObserver < "u" ? new ResizeObserver((i) => {
    const l = () => {
      const c = i[0].target;
      c.offsetParent !== null && t(c);
    };
    n ? l() : requestAnimationFrame(l);
  }) : null, [t, n]);
  return r = (i) => {
    i && e ? (s == null || s.observe(i), o.current = i) : (o.current && (s == null || s.unobserve(o.current)), o.current = null);
  }, { callbackRef: r, ref: o };
}
function kn(t, e, n, o, r, s, i, l, c) {
  const a = H.useCallback(
    (p) => {
      const I = So(p.children, e, l ? "offsetWidth" : "offsetHeight", r);
      let h = p.parentElement;
      for (; !h.dataset.virtuosoScroller; )
        h = h.parentElement;
      const f = h.lastElementChild.dataset.viewportType === "window";
      let C;
      f && (C = h.ownerDocument.defaultView);
      const w = i ? l ? i.scrollLeft : i.scrollTop : f ? l ? C.scrollX || C.document.documentElement.scrollLeft : C.scrollY || C.document.documentElement.scrollTop : l ? h.scrollLeft : h.scrollTop, S = i ? l ? i.scrollWidth : i.scrollHeight : f ? l ? C.document.documentElement.scrollWidth : C.document.documentElement.scrollHeight : l ? h.scrollWidth : h.scrollHeight, m = i ? l ? i.offsetWidth : i.offsetHeight : f ? l ? C.innerWidth : C.innerHeight : l ? h.offsetWidth : h.offsetHeight;
      o({
        scrollHeight: S,
        scrollTop: Math.max(w, 0),
        viewportHeight: m
      }), s == null || s(
        l ? dn("column-gap", getComputedStyle(p).columnGap, r) : dn("row-gap", getComputedStyle(p).rowGap, r)
      ), I !== null && t(I);
    },
    [t, e, r, s, i, o, l]
  );
  return Ge(a, n, c);
}
function So(t, e, n, o) {
  const r = t.length;
  if (r === 0)
    return null;
  const s = [];
  for (let i = 0; i < r; i++) {
    const l = t.item(i);
    if (l.dataset.index === void 0)
      continue;
    const c = parseInt(l.dataset.index), a = parseFloat(l.dataset.knownSize), p = e(l, n);
    if (p === 0 && o("Zero-sized element, this should not happen", { child: l }, mt.ERROR), p === a)
      continue;
    const I = s[s.length - 1];
    s.length === 0 || I.size !== p || I.endIndex !== c - 1 ? s.push({ endIndex: c, size: p, startIndex: c }) : s[s.length - 1].endIndex++;
  }
  return s;
}
function dn(t, e, n) {
  return e !== "normal" && !(e != null && e.endsWith("px")) && n(`${t} was not resolved to pixel value correctly`, e, mt.WARN), e === "normal" ? 0 : parseInt(e != null ? e : "0", 10);
}
function _e(t, e, n) {
  const o = H.useRef(null), r = H.useCallback(
    (c) => {
      if (!(c != null && c.offsetParent))
        return;
      const a = c.getBoundingClientRect(), p = a.width;
      let I, h;
      if (e) {
        const f = e.getBoundingClientRect(), C = a.top - f.top;
        h = f.height - Math.max(0, C), I = C + e.scrollTop;
      } else {
        const f = i.current.ownerDocument.defaultView;
        h = f.innerHeight - Math.max(0, a.top), I = a.top + f.scrollY;
      }
      o.current = {
        offsetTop: I,
        visibleHeight: h,
        visibleWidth: p
      }, t(o.current);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [t, e]
  ), { callbackRef: s, ref: i } = Ge(r, !0, n), l = H.useCallback(() => {
    r(i.current);
  }, [r, i]);
  return H.useEffect(() => {
    var c;
    if (e) {
      e.addEventListener("scroll", l);
      const a = new ResizeObserver(() => {
        requestAnimationFrame(l);
      });
      return a.observe(e), () => {
        e.removeEventListener("scroll", l), a.unobserve(e);
      };
    } else {
      const a = (c = i.current) == null ? void 0 : c.ownerDocument.defaultView;
      return a == null || a.addEventListener("scroll", l), a == null || a.addEventListener("resize", l), () => {
        a == null || a.removeEventListener("scroll", l), a == null || a.removeEventListener("resize", l);
      };
    }
  }, [l, e, i]), s;
}
const at = U(
  () => {
    const t = $(), e = $(), n = v(0), o = $(), r = v(0), s = $(), i = $(), l = v(0), c = v(0), a = v(0), p = v(0), I = $(), h = $(), f = v(!1), C = v(!1), w = v(!1);
    return O(
      x(
        t,
        E(({ scrollTop: S }) => S)
      ),
      e
    ), O(
      x(
        t,
        E(({ scrollHeight: S }) => S)
      ),
      i
    ), O(e, r), {
      deviation: n,
      fixedFooterHeight: a,
      fixedHeaderHeight: c,
      footerHeight: p,
      headerHeight: l,
      horizontalDirection: C,
      scrollBy: h,
      // input
      scrollContainerState: t,
      scrollHeight: i,
      scrollingInProgress: f,
      // signals
      scrollTo: I,
      scrollTop: e,
      skipAnimationFrameInResizeObserver: w,
      smoothScrollTargetReached: o,
      // state
      statefulScrollTop: r,
      viewportHeight: s
    };
  },
  [],
  { singleton: !0 }
), oe = { lvl: 0 };
function Fn(t, e) {
  const n = t.length;
  if (n === 0)
    return [];
  let { index: o, value: r } = e(t[0]);
  const s = [];
  for (let i = 1; i < n; i++) {
    const { index: l, value: c } = e(t[i]);
    s.push({ end: l - 1, start: o, value: r }), o = l, r = c;
  }
  return s.push({ end: 1 / 0, start: o, value: r }), s;
}
function j(t) {
  return t === oe;
}
function re(t, e) {
  if (!j(t))
    return e === t.k ? t.v : e < t.k ? re(t.l, e) : re(t.r, e);
}
function Ct(t, e, n = "k") {
  if (j(t))
    return [-1 / 0, void 0];
  if (Number(t[n]) === e)
    return [t.k, t.v];
  if (Number(t[n]) < e) {
    const o = Ct(t.r, e, n);
    return o[0] === -1 / 0 ? [t.k, t.v] : o;
  }
  return Ct(t.l, e, n);
}
function pt(t, e, n) {
  return j(t) ? zn(e, n, 1) : e === t.k ? ot(t, { k: e, v: n }) : e < t.k ? fn(ot(t, { l: pt(t.l, e, n) })) : fn(ot(t, { r: pt(t.r, e, n) }));
}
function Ut() {
  return oe;
}
function ye(t, e, n) {
  if (j(t))
    return [];
  const o = Ct(t, e)[0];
  return xo(ze(t, o, n));
}
function Le(t, e) {
  if (j(t)) return oe;
  const { k: n, l: o, r } = t;
  if (e === n) {
    if (j(o))
      return r;
    if (j(r))
      return o;
    {
      const [s, i] = Ln(o);
      return ge(ot(t, { k: s, l: On(o), v: i }));
    }
  } else return e < n ? ge(ot(t, { l: Le(o, e) })) : ge(ot(t, { r: Le(r, e) }));
}
function Gt(t) {
  return j(t) ? [] : [...Gt(t.l), { k: t.k, v: t.v }, ...Gt(t.r)];
}
function ze(t, e, n) {
  if (j(t))
    return [];
  const { k: o, l: r, r: s, v: i } = t;
  let l = [];
  return o > e && (l = l.concat(ze(r, e, n))), o >= e && o <= n && l.push({ k: o, v: i }), o <= n && (l = l.concat(ze(s, e, n))), l;
}
function ge(t) {
  const { l: e, lvl: n, r: o } = t;
  if (o.lvl >= n - 1 && e.lvl >= n - 1)
    return t;
  if (n > o.lvl + 1) {
    if (Ee(e))
      return Vn(ot(t, { lvl: n - 1 }));
    if (!j(e) && !j(e.r))
      return ot(e.r, {
        l: ot(e, { r: e.r.l }),
        lvl: n,
        r: ot(t, {
          l: e.r.r,
          lvl: n - 1
        })
      });
    throw new Error("Unexpected empty nodes");
  } else {
    if (Ee(t))
      return Ve(ot(t, { lvl: n - 1 }));
    if (!j(o) && !j(o.l)) {
      const r = o.l, s = Ee(r) ? o.lvl - 1 : o.lvl;
      return ot(r, {
        l: ot(t, {
          lvl: n - 1,
          r: r.l
        }),
        lvl: r.lvl + 1,
        r: Ve(ot(o, { l: r.r, lvl: s }))
      });
    } else
      throw new Error("Unexpected empty nodes");
  }
}
function ot(t, e) {
  return zn(
    e.k !== void 0 ? e.k : t.k,
    e.v !== void 0 ? e.v : t.v,
    e.lvl !== void 0 ? e.lvl : t.lvl,
    e.l !== void 0 ? e.l : t.l,
    e.r !== void 0 ? e.r : t.r
  );
}
function On(t) {
  return j(t.r) ? t.l : ge(ot(t, { r: On(t.r) }));
}
function Ee(t) {
  return j(t) || t.lvl > t.r.lvl;
}
function Ln(t) {
  return j(t.r) ? [t.k, t.v] : Ln(t.r);
}
function zn(t, e, n, o = oe, r = oe) {
  return { k: t, l: o, lvl: n, r, v: e };
}
function fn(t) {
  return Ve(Vn(t));
}
function Vn(t) {
  const { l: e } = t;
  return !j(e) && e.lvl === t.lvl ? ot(e, { r: ot(t, { l: e.r }) }) : t;
}
function Ve(t) {
  const { lvl: e, r: n } = t;
  return !j(n) && !j(n.r) && n.lvl === e && n.r.lvl === e ? ot(n, { l: ot(t, { r: n.l }), lvl: e + 1 }) : t;
}
function xo(t) {
  return Fn(t, ({ k: e, v: n }) => ({ index: e, value: n }));
}
function Pn(t, e) {
  return !!(t && t.startIndex === e.startIndex && t.endIndex === e.endIndex);
}
function se(t, e) {
  return !!(t && t[0] === e[0] && t[1] === e[1]);
}
const Ne = U(
  () => ({ recalcInProgress: v(!1) }),
  [],
  { singleton: !0 }
);
function An(t, e, n) {
  return t[Se(t, e, n)];
}
function Se(t, e, n, o = 0) {
  let r = t.length - 1;
  for (; o <= r; ) {
    const s = Math.floor((o + r) / 2), i = t[s], l = n(i, e);
    if (l === 0)
      return s;
    if (l === -1) {
      if (r - o < 2)
        return s - 1;
      r = s - 1;
    } else {
      if (r === o)
        return s;
      o = s + 1;
    }
  }
  throw new Error(`Failed binary finding record in array - ${t.join(",")}, searched for ${e}`);
}
function To(t, e, n, o) {
  const r = Se(t, e, o), s = Se(t, n, o, r);
  return t.slice(r, s + 1);
}
function wt(t, e) {
  return Math.round(t.getBoundingClientRect()[e]);
}
function Re(t) {
  return !j(t.groupOffsetTree);
}
function De({ index: t }, e) {
  return e === t ? 0 : e < t ? -1 : 1;
}
function Co() {
  return {
    groupIndices: [],
    groupOffsetTree: Ut(),
    lastIndex: 0,
    lastOffset: 0,
    lastSize: 0,
    offsetTree: [],
    sizeTree: Ut()
  };
}
function wo(t, e) {
  let n = j(t) ? 0 : 1 / 0;
  for (const o of e) {
    const { endIndex: r, size: s, startIndex: i } = o;
    if (n = Math.min(n, i), j(t)) {
      t = pt(t, 0, s);
      continue;
    }
    const l = ye(t, i - 1, r + 1);
    if (l.some(Bo(o)))
      continue;
    let c = !1, a = !1;
    for (const { end: p, start: I, value: h } of l)
      c ? (r >= I || s === h) && (t = Le(t, I)) : (a = h !== s, c = !0), p > r && r >= I && h !== s && (t = pt(t, r + 1, h));
    a && (t = pt(t, i, s));
  }
  return [t, n];
}
function vo(t) {
  return typeof t.groupIndex < "u";
}
function yo({ offset: t }, e) {
  return e === t ? 0 : e < t ? -1 : 1;
}
function ie(t, e, n) {
  if (e.length === 0)
    return 0;
  const { index: o, offset: r, size: s } = An(e, t, De), i = t - o, l = s * i + (i - 1) * n + r;
  return l > 0 ? l + n : l;
}
function Mn(t, e) {
  if (!Re(e))
    return t;
  let n = 0;
  for (; e.groupIndices[n] <= t + n; )
    n++;
  return t + n;
}
function Wn(t, e, n) {
  if (vo(t))
    return e.groupIndices[t.groupIndex] + 1;
  {
    const o = t.index === "LAST" ? n : t.index;
    let r = Mn(o, e);
    return r = Math.max(0, r, Math.min(n, r)), r;
  }
}
function Ro(t, e, n, o = 0) {
  return o > 0 && (e = Math.max(e, An(t, o, De).offset)), Fn(To(t, e, n, yo), Eo);
}
function bo(t, [e, n, o, r]) {
  e.length > 0 && o("received item sizes", e, mt.DEBUG);
  const s = t.sizeTree;
  let i = s, l = 0;
  if (n.length > 0 && j(s) && e.length === 2) {
    const h = e[0].size, f = e[1].size;
    i = n.reduce((C, w) => pt(pt(C, w, h), w + 1, f), i);
  } else
    [i, l] = wo(i, e);
  if (i === s)
    return t;
  const { lastIndex: c, lastOffset: a, lastSize: p, offsetTree: I } = Pe(t.offsetTree, l, i, r);
  return {
    groupIndices: n,
    groupOffsetTree: n.reduce((h, f) => pt(h, f, ie(f, I, r)), Ut()),
    lastIndex: c,
    lastOffset: a,
    lastSize: p,
    offsetTree: I,
    sizeTree: i
  };
}
function Ho(t) {
  return Gt(t).map(({ k: e, v: n }, o, r) => {
    const s = r[o + 1];
    return { endIndex: s ? s.k - 1 : 1 / 0, size: n, startIndex: e };
  });
}
function mn(t, e) {
  let n = 0, o = 0;
  for (; n < t; )
    n += e[o + 1] - e[o] - 1, o++;
  return o - (n === t ? 0 : 1);
}
function Pe(t, e, n, o) {
  let r = t, s = 0, i = 0, l = 0, c = 0;
  if (e !== 0) {
    c = Se(r, e - 1, De), l = r[c].offset;
    const p = Ct(n, e - 1);
    s = p[0], i = p[1], r.length && r[c].size === Ct(n, e)[1] && (c -= 1), r = r.slice(0, c + 1);
  } else
    r = [];
  for (const { start: a, value: p } of ye(n, e, 1 / 0)) {
    const I = a - s, h = I * i + l + I * o;
    r.push({
      index: a,
      offset: h,
      size: p
    }), s = a, l = h, i = p;
  }
  return {
    lastIndex: s,
    lastOffset: l,
    lastSize: i,
    offsetTree: r
  };
}
function Eo(t) {
  return { index: t.index, value: t };
}
function Bo(t) {
  const { endIndex: e, size: n, startIndex: o } = t;
  return (r) => r.start === o && (r.end === e || r.end === 1 / 0) && r.value === n;
}
const ko = {
  offsetHeight: "height",
  offsetWidth: "width"
}, Et = U(
  ([{ log: t }, { recalcInProgress: e }]) => {
    const n = $(), o = $(), r = ct(o, 0), s = $(), i = $(), l = v(0), c = v([]), a = v(void 0), p = v(void 0), I = v((g, d) => wt(g, ko[d])), h = v(void 0), f = v(0), C = Co(), w = ct(
      x(n, _(c, t, f), Rt(bo, C), Y()),
      C
    ), S = ct(
      x(
        c,
        Y(),
        Rt((g, d) => ({ current: d, prev: g.current }), {
          current: [],
          prev: []
        }),
        E(({ prev: g }) => g)
      ),
      []
    );
    O(
      x(
        c,
        P((g) => g.length > 0),
        _(w, f),
        E(([g, d, b]) => {
          const k = g.reduce((F, L, V) => pt(F, L, ie(L, d.offsetTree, b) || V), Ut());
          return {
            ...d,
            groupIndices: g,
            groupOffsetTree: k
          };
        })
      ),
      w
    ), O(
      x(
        o,
        _(w),
        P(([g, { lastIndex: d }]) => g < d),
        E(([g, { lastIndex: d, lastSize: b }]) => [
          {
            endIndex: d,
            size: b,
            startIndex: g
          }
        ])
      ),
      n
    ), O(a, p);
    const m = ct(
      x(
        a,
        E((g) => g === void 0)
      ),
      !0
    );
    O(
      x(
        p,
        P((g) => g !== void 0 && j(st(w).sizeTree)),
        E((g) => [{ endIndex: 0, size: g, startIndex: 0 }])
      ),
      n
    );
    const u = ht(
      x(
        n,
        _(w),
        Rt(
          ({ sizes: g }, [d, b]) => ({
            changed: b !== g,
            sizes: b
          }),
          { changed: !1, sizes: C }
        ),
        E((g) => g.changed)
      )
    );
    K(
      x(
        l,
        Rt(
          (g, d) => ({ diff: g.prev - d, prev: d }),
          { diff: 0, prev: 0 }
        ),
        E((g) => g.diff)
      ),
      (g) => {
        const { groupIndices: d } = st(w);
        if (g > 0)
          W(e, !0), W(s, g + mn(g, d));
        else if (g < 0) {
          const b = st(S);
          b.length > 0 && (g -= mn(-g, b)), W(i, g);
        }
      }
    ), K(x(l, _(t)), ([g, d]) => {
      g < 0 && d(
        "`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value",
        { firstItemIndex: l },
        mt.ERROR
      );
    });
    const T = ht(s);
    O(
      x(
        s,
        _(w),
        E(([g, d]) => {
          const b = d.groupIndices.length > 0, k = [], F = d.lastSize;
          if (b) {
            const L = re(d.sizeTree, 0);
            let V = 0, D = 0;
            for (; V < g; ) {
              const B = d.groupIndices[D], q = d.groupIndices.length === D + 1 ? 1 / 0 : d.groupIndices[D + 1] - B - 1;
              k.push({
                endIndex: B,
                size: L,
                startIndex: B
              }), k.push({
                endIndex: B + 1 + q - 1,
                size: F,
                startIndex: B + 1
              }), D++, V += q + 1;
            }
            const J = Gt(d.sizeTree);
            return V !== g && J.shift(), J.reduce(
              (B, { k: q, v: it }) => {
                let dt = B.ranges;
                return B.prevSize !== 0 && (dt = [
                  ...B.ranges,
                  {
                    endIndex: q + g - 1,
                    size: B.prevSize,
                    startIndex: B.prevIndex
                  }
                ]), {
                  prevIndex: q + g,
                  prevSize: it,
                  ranges: dt
                };
              },
              {
                prevIndex: g,
                prevSize: 0,
                ranges: k
              }
            ).ranges;
          }
          return Gt(d.sizeTree).reduce(
            (L, { k: V, v: D }) => ({
              prevIndex: V + g,
              prevSize: D,
              ranges: [...L.ranges, { endIndex: V + g - 1, size: L.prevSize, startIndex: L.prevIndex }]
            }),
            {
              prevIndex: 0,
              prevSize: F,
              ranges: []
            }
          ).ranges;
        })
      ),
      n
    );
    const R = ht(
      x(
        i,
        _(w, f),
        E(([g, { offsetTree: d }, b]) => {
          const k = -g;
          return ie(k, d, b);
        })
      )
    );
    return O(
      x(
        i,
        _(w, f),
        E(([g, d, b]) => {
          if (d.groupIndices.length > 0) {
            if (j(d.sizeTree))
              return d;
            let F = Ut();
            const L = st(S);
            let V = 0, D = 0, J = 0;
            for (; V < -g; ) {
              J = L[D];
              const B = L[D + 1] - J - 1;
              D++, V += B + 1;
            }
            if (F = Gt(d.sizeTree).reduce((B, { k: q, v: it }) => pt(B, Math.max(0, q + g), it), F), V !== -g) {
              const B = re(d.sizeTree, J);
              F = pt(F, 0, B);
              const q = Ct(d.sizeTree, -g + 1)[1];
              F = pt(F, 1, q);
            }
            return {
              ...d,
              sizeTree: F,
              ...Pe(d.offsetTree, 0, F, b)
            };
          } else {
            const F = Gt(d.sizeTree).reduce((L, { k: V, v: D }) => pt(L, Math.max(0, V + g), D), Ut());
            return {
              ...d,
              sizeTree: F,
              ...Pe(d.offsetTree, 0, F, b)
            };
          }
        })
      ),
      w
    ), {
      beforeUnshiftWith: T,
      // input
      data: h,
      defaultItemSize: p,
      firstItemIndex: l,
      fixedItemSize: a,
      gap: f,
      groupIndices: c,
      itemSize: I,
      listRefresh: u,
      shiftWith: i,
      shiftWithOffset: R,
      sizeRanges: n,
      // output
      sizes: w,
      statefulTotalCount: r,
      totalCount: o,
      trackItemSizes: m,
      unshiftWith: s
    };
  },
  X(Vt, Ne),
  { singleton: !0 }
);
function Fo(t) {
  return t.reduce(
    (e, n) => (e.groupIndices.push(e.totalCount), e.totalCount += n + 1, e),
    {
      groupIndices: [],
      totalCount: 0
    }
  );
}
const Gn = U(
  ([{ groupIndices: t, sizes: e, totalCount: n }, { headerHeight: o, scrollTop: r }]) => {
    const s = $(), i = $(), l = ht(x(s, E(Fo)));
    return O(
      x(
        l,
        E((c) => c.totalCount)
      ),
      n
    ), O(
      x(
        l,
        E((c) => c.groupIndices)
      ),
      t
    ), O(
      x(
        rt(r, e, o),
        P(([c, a]) => Re(a)),
        E(([c, a, p]) => Ct(a.groupOffsetTree, Math.max(c - p, 0), "v")[0]),
        Y(),
        E((c) => [c])
      ),
      i
    ), { groupCounts: s, topItemsIndexes: i };
  },
  X(Et, at)
), Pt = U(
  ([{ log: t }]) => {
    const e = v(!1), n = ht(
      x(
        e,
        P((o) => o),
        Y()
      )
    );
    return K(e, (o) => {
      o && st(t)("props updated", {}, mt.DEBUG);
    }), { didMount: n, propsReady: e };
  },
  X(Vt),
  { singleton: !0 }
), Oo = typeof document < "u" && "scrollBehavior" in document.documentElement.style;
function _n(t) {
  const e = typeof t == "number" ? { index: t } : t;
  return e.align || (e.align = "start"), (!e.behavior || !Oo) && (e.behavior = "auto"), e.offset || (e.offset = 0), e;
}
const ce = U(
  ([
    { gap: t, listRefresh: e, sizes: n, totalCount: o },
    {
      fixedFooterHeight: r,
      fixedHeaderHeight: s,
      footerHeight: i,
      headerHeight: l,
      scrollingInProgress: c,
      scrollTo: a,
      smoothScrollTargetReached: p,
      viewportHeight: I
    },
    { log: h }
  ]) => {
    const f = $(), C = $(), w = v(0);
    let S = null, m = null, u = null;
    function T() {
      S && (S(), S = null), u && (u(), u = null), m && (clearTimeout(m), m = null), W(c, !1);
    }
    return O(
      x(
        f,
        _(n, I, o, w, l, i, h),
        _(t, s, r),
        E(
          ([
            [R, g, d, b, k, F, L, V],
            D,
            J,
            nt
          ]) => {
            const B = _n(R), { align: q, behavior: it, offset: dt } = B, St = b - 1, ft = Wn(B, g, St);
            let ut = ie(ft, g.offsetTree, D) + F;
            q === "end" ? (ut += J + Ct(g.sizeTree, ft)[1] - d + nt, ft === St && (ut += L)) : q === "center" ? ut += (J + Ct(g.sizeTree, ft)[1] - d + nt) / 2 : ut -= k, dt && (ut += dt);
            const At = (xt) => {
              T(), xt ? (V("retrying to scroll to", { location: R }, mt.DEBUG), W(f, R)) : (W(C, !0), V("list did not change, scroll successful", {}, mt.DEBUG));
            };
            if (T(), it === "smooth") {
              let xt = !1;
              u = K(e, (Xt) => {
                xt = xt || Xt;
              }), S = bt(p, () => {
                At(xt);
              });
            } else
              S = bt(x(e, Lo(150)), At);
            return m = setTimeout(() => {
              T();
            }, 1200), W(c, !0), V("scrolling from index to", { behavior: it, index: ft, top: ut }, mt.DEBUG), { behavior: it, top: ut };
          }
        )
      ),
      a
    ), {
      scrollTargetReached: C,
      scrollToIndex: f,
      topListHeight: w
    };
  },
  X(Et, at, Vt),
  { singleton: !0 }
);
function Lo(t) {
  return (e) => {
    const n = setTimeout(() => {
      e(!1);
    }, t);
    return (o) => {
      o && (e(!0), clearTimeout(n));
    };
  };
}
function $e(t, e) {
  t == 0 ? e() : requestAnimationFrame(() => {
    $e(t - 1, e);
  });
}
function Ue(t, e) {
  const n = e - 1;
  return typeof t == "number" ? t : t.index === "LAST" ? n : t.index;
}
const ue = U(
  ([{ defaultItemSize: t, listRefresh: e, sizes: n }, { scrollTop: o }, { scrollTargetReached: r, scrollToIndex: s }, { didMount: i }]) => {
    const l = v(!0), c = v(0), a = v(!0);
    return O(
      x(
        i,
        _(c),
        P(([p, I]) => !!I),
        yt(!1)
      ),
      l
    ), O(
      x(
        i,
        _(c),
        P(([p, I]) => !!I),
        yt(!1)
      ),
      a
    ), K(
      x(
        rt(e, i),
        _(l, n, t, a),
        P(([[, p], I, { sizeTree: h }, f, C]) => p && (!j(h) || Me(f)) && !I && !C),
        _(c)
      ),
      ([, p]) => {
        bt(r, () => {
          W(a, !0);
        }), $e(4, () => {
          bt(o, () => {
            W(l, !0);
          }), W(s, p);
        });
      }
    ), {
      initialItemFinalLocationReached: a,
      initialTopMostItemIndex: c,
      scrolledToInitialItem: l
    };
  },
  X(Et, at, ce, Pt),
  { singleton: !0 }
);
function Nn(t, e) {
  return Math.abs(t - e) < 1.01;
}
const le = "up", te = "down", zo = "none", Vo = {
  atBottom: !1,
  notAtBottomBecause: "NOT_SHOWING_LAST_ITEM",
  state: {
    offsetBottom: 0,
    scrollHeight: 0,
    scrollTop: 0,
    viewportHeight: 0
  }
}, Po = 0, ae = U(([{ footerHeight: t, headerHeight: e, scrollBy: n, scrollContainerState: o, scrollTop: r, viewportHeight: s }]) => {
  const i = v(!1), l = v(!0), c = $(), a = $(), p = v(4), I = v(Po), h = ct(
    x(
      an(x(A(r), jt(1), yt(!0)), x(A(r), jt(1), yt(!1), un(100))),
      Y()
    ),
    !1
  ), f = ct(
    x(an(x(n, yt(!0)), x(n, yt(!1), un(200))), Y()),
    !1
  );
  O(
    x(
      rt(A(r), A(I)),
      E(([u, T]) => u <= T),
      Y()
    ),
    l
  ), O(x(l, Lt(50)), a);
  const C = ht(
    x(
      rt(o, A(s), A(e), A(t), A(p)),
      Rt((u, [{ scrollHeight: T, scrollTop: R }, g, d, b, k]) => {
        const F = R + g - T > -k, L = {
          scrollHeight: T,
          scrollTop: R,
          viewportHeight: g
        };
        if (F) {
          let D, J;
          return R > u.state.scrollTop ? (D = "SCROLLED_DOWN", J = u.state.scrollTop - R) : (D = "SIZE_DECREASED", J = u.state.scrollTop - R || u.scrollTopDelta), {
            atBottom: !0,
            atBottomBecause: D,
            scrollTopDelta: J,
            state: L
          };
        }
        let V;
        return L.scrollHeight > u.state.scrollHeight ? V = "SIZE_INCREASED" : g < u.state.viewportHeight ? V = "VIEWPORT_HEIGHT_DECREASING" : R < u.state.scrollTop ? V = "SCROLLING_UPWARDS" : V = "NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM", {
          atBottom: !1,
          notAtBottomBecause: V,
          state: L
        };
      }, Vo),
      Y((u, T) => u && u.atBottom === T.atBottom)
    )
  ), w = ct(
    x(
      o,
      Rt(
        (u, { scrollHeight: T, scrollTop: R, viewportHeight: g }) => {
          if (Nn(u.scrollHeight, T))
            return {
              changed: !1,
              jump: 0,
              scrollHeight: T,
              scrollTop: R
            };
          {
            const d = T - (R + g) < 1;
            return u.scrollTop !== R && d ? {
              changed: !0,
              jump: u.scrollTop - R,
              scrollHeight: T,
              scrollTop: R
            } : {
              changed: !0,
              jump: 0,
              scrollHeight: T,
              scrollTop: R
            };
          }
        },
        { changed: !1, jump: 0, scrollHeight: 0, scrollTop: 0 }
      ),
      P((u) => u.changed),
      E((u) => u.jump)
    ),
    0
  );
  O(
    x(
      C,
      E((u) => u.atBottom)
    ),
    i
  ), O(x(i, Lt(50)), c);
  const S = v(te);
  O(
    x(
      o,
      E(({ scrollTop: u }) => u),
      Y(),
      Rt(
        (u, T) => st(f) ? { direction: u.direction, prevScrollTop: T } : { direction: T < u.prevScrollTop ? le : te, prevScrollTop: T },
        { direction: te, prevScrollTop: 0 }
      ),
      E((u) => u.direction)
    ),
    S
  ), O(x(o, Lt(50), yt(zo)), S);
  const m = v(0);
  return O(
    x(
      h,
      P((u) => !u),
      yt(0)
    ),
    m
  ), O(
    x(
      r,
      Lt(100),
      _(h),
      P(([u, T]) => !!T),
      Rt(([u, T], [R]) => [T, R], [0, 0]),
      E(([u, T]) => T - u)
    ),
    m
  ), {
    atBottomState: C,
    atBottomStateChange: c,
    atBottomThreshold: p,
    atTopStateChange: a,
    atTopThreshold: I,
    isAtBottom: i,
    isAtTop: l,
    isScrolling: h,
    lastJumpDueToItemResize: w,
    scrollDirection: S,
    scrollVelocity: m
  };
}, X(at)), xe = "top", Te = "bottom", pn = "none";
function hn(t, e, n) {
  return typeof t == "number" ? n === le && e === xe || n === te && e === Te ? t : 0 : n === le ? e === xe ? t.main : t.reverse : e === Te ? t.main : t.reverse;
}
function gn(t, e) {
  var n;
  return typeof t == "number" ? t : (n = t[e]) != null ? n : 0;
}
const Ke = U(
  ([{ deviation: t, fixedHeaderHeight: e, headerHeight: n, scrollTop: o, viewportHeight: r }]) => {
    const s = $(), i = v(0), l = v(0), c = v(0), a = ct(
      x(
        rt(
          A(o),
          A(r),
          A(n),
          A(s, se),
          A(c),
          A(i),
          A(e),
          A(t),
          A(l)
        ),
        E(
          ([
            p,
            I,
            h,
            [f, C],
            w,
            S,
            m,
            u,
            T
          ]) => {
            const R = p - u, g = S + m, d = Math.max(h - R, 0);
            let b = pn;
            const k = gn(T, xe), F = gn(T, Te);
            return f -= u, f += h + m, C += h + m, C -= u, f > p + g - k && (b = le), C < p - d + I + F && (b = te), b !== pn ? [
              Math.max(R - h - hn(w, xe, b) - k, 0),
              R - d - m + I + hn(w, Te, b) + F
            ] : null;
          }
        ),
        P((p) => p != null),
        Y(se)
      ),
      [0, 0]
    );
    return {
      increaseViewportBy: l,
      // input
      listBoundary: s,
      overscan: c,
      topListHeight: i,
      // output
      visibleRange: a
    };
  },
  X(at),
  { singleton: !0 }
);
function Ao(t, e, n) {
  if (Re(e)) {
    const o = Mn(t, e);
    return [
      { index: Ct(e.groupOffsetTree, o)[0], offset: 0, size: 0 },
      { data: n == null ? void 0 : n[0], index: o, offset: 0, size: 0 }
    ];
  }
  return [{ data: n == null ? void 0 : n[0], index: t, offset: 0, size: 0 }];
}
const Be = {
  bottom: 0,
  firstItemIndex: 0,
  items: [],
  offsetBottom: 0,
  offsetTop: 0,
  top: 0,
  topItems: [],
  topListHeight: 0,
  totalCount: 0
};
function Ie(t, e, n, o, r, s) {
  const { lastIndex: i, lastOffset: l, lastSize: c } = r;
  let a = 0, p = 0;
  if (t.length > 0) {
    a = t[0].offset;
    const w = t[t.length - 1];
    p = w.offset + w.size;
  }
  const I = n - i, h = l + I * c + (I - 1) * o, f = a, C = h - p;
  return {
    bottom: p,
    firstItemIndex: s,
    items: In(t, r, s),
    offsetBottom: C,
    offsetTop: a,
    top: f,
    topItems: In(e, r, s),
    topListHeight: e.reduce((w, S) => S.size + w, 0),
    totalCount: n
  };
}
function Dn(t, e, n, o, r, s) {
  let i = 0;
  if (n.groupIndices.length > 0)
    for (const p of n.groupIndices) {
      if (p - i >= t)
        break;
      i++;
    }
  const l = t + i, c = Ue(e, l), a = Array.from({ length: l }).map((p, I) => ({
    data: s[I + c],
    index: I + c,
    offset: 0,
    size: 0
  }));
  return Ie(a, [], l, r, n, o);
}
function In(t, e, n) {
  if (t.length === 0)
    return [];
  if (!Re(e))
    return t.map((a) => ({ ...a, index: a.index + n, originalIndex: a.index }));
  const o = t[0].index, r = t[t.length - 1].index, s = [], i = ye(e.groupOffsetTree, o, r);
  let l, c = 0;
  for (const a of t) {
    (!l || l.end < a.index) && (l = i.shift(), c = e.groupIndices.indexOf(l.start));
    let p;
    a.index === l.start ? p = {
      index: c,
      type: "group"
    } : p = {
      groupIndex: c,
      index: a.index - (c + 1) + n
    }, s.push({
      ...p,
      data: a.data,
      offset: a.offset,
      originalIndex: a.index,
      size: a.size
    });
  }
  return s;
}
const _t = U(
  ([
    { data: t, firstItemIndex: e, gap: n, sizes: o, totalCount: r },
    s,
    { listBoundary: i, topListHeight: l, visibleRange: c },
    { initialTopMostItemIndex: a, scrolledToInitialItem: p },
    { topListHeight: I },
    h,
    { didMount: f },
    { recalcInProgress: C }
  ]) => {
    const w = v([]), S = v(0), m = $();
    O(s.topItemsIndexes, w);
    const u = ct(
      x(
        rt(
          f,
          C,
          A(c, se),
          A(r),
          A(o),
          A(a),
          p,
          A(w),
          A(e),
          A(n),
          t
        ),
        P(([d, b, , k, , , , , , , F]) => {
          const L = F && F.length !== k;
          return d && !b && !L;
        }),
        E(
          ([
            ,
            ,
            [d, b],
            k,
            F,
            L,
            V,
            D,
            J,
            nt,
            B
          ]) => {
            const q = F, { offsetTree: it, sizeTree: dt } = q, St = st(S);
            if (k === 0)
              return { ...Be, totalCount: k };
            if (d === 0 && b === 0)
              return St === 0 ? { ...Be, totalCount: k } : Dn(St, L, F, J, nt, B || []);
            if (j(dt))
              return St > 0 ? null : Ie(
                Ao(Ue(L, k), q, B),
                [],
                k,
                nt,
                q,
                J
              );
            const ft = [];
            if (D.length > 0) {
              const Mt = D[0], vt = D[D.length - 1];
              let Bt = 0;
              for (const y of ye(dt, Mt, vt)) {
                const N = y.value, Q = Math.max(y.start, Mt), lt = Math.min(y.end, vt);
                for (let tt = Q; tt <= lt; tt++)
                  ft.push({ data: B == null ? void 0 : B[tt], index: tt, offset: Bt, size: N }), Bt += N;
              }
            }
            if (!V)
              return Ie([], ft, k, nt, q, J);
            const ut = D.length > 0 ? D[D.length - 1] + 1 : 0, At = Ro(it, d, b, ut);
            if (At.length === 0)
              return null;
            const xt = k - 1, Xt = ve([], (Mt) => {
              for (const vt of At) {
                const Bt = vt.value;
                let y = Bt.offset, N = vt.start;
                const Q = Bt.size;
                if (Bt.offset < d) {
                  N += Math.floor((d - Bt.offset + nt) / (Q + nt));
                  const tt = N - vt.start;
                  y += tt * Q + tt * nt;
                }
                N < ut && (y += (ut - N) * Q, N = ut);
                const lt = Math.min(vt.end, xt);
                for (let tt = N; tt <= lt && !(y >= b); tt++)
                  Mt.push({ data: B == null ? void 0 : B[tt], index: tt, offset: y, size: Q }), y += Q + nt;
              }
            });
            return Ie(Xt, ft, k, nt, q, J);
          }
        ),
        //@ts-expect-error filter needs to be fixed
        P((d) => d !== null),
        Y()
      ),
      Be
    );
    O(
      x(
        t,
        P(Me),
        E((d) => d == null ? void 0 : d.length)
      ),
      r
    ), O(
      x(
        u,
        E((d) => d.topListHeight)
      ),
      I
    ), O(I, l), O(
      x(
        u,
        E((d) => [d.top, d.bottom])
      ),
      i
    ), O(
      x(
        u,
        E((d) => d.items)
      ),
      m
    );
    const T = ht(
      x(
        u,
        P(({ items: d }) => d.length > 0),
        _(r, t),
        P(([{ items: d }, b]) => d[d.length - 1].originalIndex === b - 1),
        E(([, d, b]) => [d - 1, b]),
        Y(se),
        E(([d]) => d)
      )
    ), R = ht(
      x(
        u,
        Lt(200),
        P(({ items: d, topItems: b }) => d.length > 0 && d[0].originalIndex === b.length),
        E(({ items: d }) => d[0].index),
        Y()
      )
    ), g = ht(
      x(
        u,
        P(({ items: d }) => d.length > 0),
        E(({ items: d }) => {
          let b = 0, k = d.length - 1;
          for (; d[b].type === "group" && b < k; )
            b++;
          for (; d[k].type === "group" && k > b; )
            k--;
          return {
            endIndex: d[k].index,
            startIndex: d[b].index
          };
        }),
        Y(Pn)
      )
    );
    return { endReached: T, initialItemCount: S, itemsRendered: m, listState: u, rangeChanged: g, startReached: R, topItemsIndexes: w, ...h };
  },
  X(
    Et,
    Gn,
    Ke,
    ue,
    ce,
    ae,
    Pt,
    Ne
  ),
  { singleton: !0 }
), $n = U(
  ([{ fixedFooterHeight: t, fixedHeaderHeight: e, footerHeight: n, headerHeight: o }, { listState: r }]) => {
    const s = $(), i = ct(
      x(
        rt(n, t, o, e, r),
        E(([l, c, a, p, I]) => l + c + a + p + I.offsetBottom + I.bottom)
      ),
      0
    );
    return O(A(i), s), { totalListHeight: i, totalListHeightChanged: s };
  },
  X(at, _t),
  { singleton: !0 }
), Mo = U(
  ([{ viewportHeight: t }, { totalListHeight: e }]) => {
    const n = v(!1), o = ct(
      x(
        rt(n, t, e),
        P(([r]) => r),
        E(([, r, s]) => Math.max(0, r - s)),
        Lt(0),
        Y()
      ),
      0
    );
    return { alignToBottom: n, paddingTopAddition: o };
  },
  X(at, $n),
  { singleton: !0 }
);
function Sn(t) {
  return t ? t === "smooth" ? "smooth" : "auto" : !1;
}
const Wo = (t, e) => typeof t == "function" ? Sn(t(e)) : e && Sn(t), Go = U(
  ([
    { listRefresh: t, totalCount: e, fixedItemSize: n },
    { atBottomState: o, isAtBottom: r },
    { scrollToIndex: s },
    { scrolledToInitialItem: i },
    { didMount: l, propsReady: c },
    { log: a },
    { scrollingInProgress: p }
  ]) => {
    const I = v(!1), h = $();
    let f = null;
    function C(S) {
      W(s, {
        align: "end",
        behavior: S,
        index: "LAST"
      });
    }
    K(
      x(
        rt(x(A(e), jt(1)), l),
        _(A(I), r, i, p),
        E(([[S, m], u, T, R, g]) => {
          let d = m && R, b = "auto";
          return d && (b = Wo(u, T || g), d = d && !!b), { followOutputBehavior: b, shouldFollow: d, totalCount: S };
        }),
        P(({ shouldFollow: S }) => S)
      ),
      ({ followOutputBehavior: S, totalCount: m }) => {
        f && (f(), f = null), st(n) ? requestAnimationFrame(() => {
          st(a)("following output to ", { totalCount: m }, mt.DEBUG), C(S);
        }) : f = bt(t, () => {
          st(a)("following output to ", { totalCount: m }, mt.DEBUG), C(S), f = null;
        });
      }
    );
    function w(S) {
      const m = bt(o, (u) => {
        S && !u.atBottom && u.notAtBottomBecause === "SIZE_INCREASED" && !f && (st(a)("scrolling to bottom due to increased size", {}, mt.DEBUG), C("auto"));
      });
      setTimeout(m, 100);
    }
    return K(
      x(
        rt(A(I), e, c),
        P(([S, , m]) => S && m),
        Rt(
          ({ value: S }, [, m]) => ({ refreshed: S === m, value: m }),
          { refreshed: !1, value: 0 }
        ),
        P(({ refreshed: S }) => S),
        _(I, e)
      ),
      ([, S]) => {
        st(i) && w(S !== !1);
      }
    ), K(h, () => {
      w(st(I) !== !1);
    }), K(rt(A(I), o), ([S, m]) => {
      S && !m.atBottom && m.notAtBottomBecause === "VIEWPORT_HEIGHT_DECREASING" && C("auto");
    }), { autoscrollToBottom: h, followOutput: I };
  },
  X(Et, ae, ce, ue, Pt, Vt, at)
), _o = U(
  ([{ data: t, firstItemIndex: e, gap: n, sizes: o }, { initialTopMostItemIndex: r }, { initialItemCount: s, listState: i }, { didMount: l }]) => (O(
    x(
      l,
      _(s),
      P(([, c]) => c !== 0),
      _(r, o, e, n, t),
      E(([[, c], a, p, I, h, f = []]) => Dn(c, a, p, I, h, f))
    ),
    i
  ), {}),
  X(Et, ue, _t, Pt),
  { singleton: !0 }
), No = U(
  ([{ didMount: t }, { scrollTo: e }, { listState: n }]) => {
    const o = v(0);
    return K(
      x(
        t,
        _(o),
        P(([, r]) => r !== 0),
        E(([, r]) => ({ top: r }))
      ),
      (r) => {
        bt(
          x(
            n,
            jt(1),
            P((s) => s.items.length > 1)
          ),
          () => {
            requestAnimationFrame(() => {
              W(e, r);
            });
          }
        );
      }
    ), {
      initialScrollTop: o
    };
  },
  X(Pt, at, _t),
  { singleton: !0 }
), Do = ({
  itemBottom: t,
  itemTop: e,
  locationParams: { align: n, behavior: o, ...r },
  viewportBottom: s,
  viewportTop: i
}) => e < i ? { ...r, align: n != null ? n : "start", behavior: o } : t > s ? { ...r, align: n != null ? n : "end", behavior: o } : null, $o = U(
  ([
    { gap: t, sizes: e, totalCount: n },
    { fixedFooterHeight: o, fixedHeaderHeight: r, headerHeight: s, scrollingInProgress: i, scrollTop: l, viewportHeight: c },
    { scrollToIndex: a }
  ]) => {
    const p = $();
    return O(
      x(
        p,
        _(e, c, n, s, r, o, l),
        _(t),
        E(([[I, h, f, C, w, S, m, u], T]) => {
          const { align: R, behavior: g, calculateViewLocation: d = Do, done: b, ...k } = I, F = Wn(I, h, C - 1), L = ie(F, h.offsetTree, T) + w + S, V = L + Ct(h.sizeTree, F)[1], D = u + S, J = u + f - m, nt = d({
            itemBottom: V,
            itemTop: L,
            locationParams: { align: R, behavior: g, ...k },
            viewportBottom: J,
            viewportTop: D
          });
          return nt ? b && bt(
            x(
              i,
              P((B) => !B),
              // skips the initial publish of false, and the cleanup call.
              // but if scrollingInProgress is true, we skip the initial publish.
              jt(st(i) ? 1 : 2)
            ),
            b
          ) : b && b(), nt;
        }),
        P((I) => I !== null)
      ),
      a
    ), {
      scrollIntoView: p
    };
  },
  X(Et, at, ce, _t, Vt),
  { singleton: !0 }
), Un = U(
  ([{ scrollVelocity: t }]) => {
    const e = v(!1), n = $(), o = v(!1);
    return O(
      x(
        t,
        _(o, e, n),
        P(([r, s]) => !!s),
        E(([r, s, i, l]) => {
          const { enter: c, exit: a } = s;
          if (i) {
            if (a(r, l))
              return !1;
          } else if (c(r, l))
            return !0;
          return i;
        }),
        Y()
      ),
      e
    ), K(
      x(rt(e, t, n), _(o)),
      ([[r, s, i], l]) => {
        r && l && l.change && l.change(s, i);
      }
    ), { isSeeking: e, scrollSeekConfiguration: o, scrollSeekRangeChanged: n, scrollVelocity: t };
  },
  X(ae),
  { singleton: !0 }
), je = U(([{ scrollContainerState: t, scrollTo: e }]) => {
  const n = $(), o = $(), r = $(), s = v(!1), i = v(void 0);
  return O(
    x(
      rt(n, o),
      E(([{ scrollHeight: l, scrollTop: c, viewportHeight: a }, { offsetTop: p }]) => ({
        scrollHeight: l,
        scrollTop: Math.max(0, c - p),
        viewportHeight: a
      }))
    ),
    t
  ), O(
    x(
      e,
      _(o),
      E(([l, { offsetTop: c }]) => ({
        ...l,
        top: l.top + c
      }))
    ),
    r
  ), {
    customScrollParent: i,
    // config
    useWindowScroll: s,
    // input
    windowScrollContainerState: n,
    // signals
    windowScrollTo: r,
    windowViewportRect: o
  };
}, X(at)), Uo = U(
  ([
    { sizeRanges: t, sizes: e },
    { headerHeight: n, scrollTop: o },
    { initialTopMostItemIndex: r },
    { didMount: s },
    { useWindowScroll: i, windowScrollContainerState: l, windowViewportRect: c }
  ]) => {
    const a = $(), p = v(void 0), I = v(null), h = v(null);
    return O(l, I), O(c, h), K(
      x(
        a,
        _(e, o, i, I, h, n)
      ),
      ([f, C, w, S, m, u, T]) => {
        const R = Ho(C.sizeTree);
        S && m !== null && u !== null && (w = m.scrollTop - u.offsetTop), w -= T, f({ ranges: R, scrollTop: w });
      }
    ), O(x(p, P(Me), E(Ko)), r), O(
      x(
        s,
        _(p),
        P(([, f]) => f !== void 0),
        Y(),
        E(([, f]) => f.ranges)
      ),
      t
    ), {
      getState: a,
      restoreStateFrom: p
    };
  },
  X(Et, at, ue, Pt, je)
);
function Ko(t) {
  return { align: "start", index: 0, offset: t.scrollTop };
}
const jo = U(([{ topItemsIndexes: t }]) => {
  const e = v(0);
  return O(
    x(
      e,
      P((n) => n >= 0),
      E((n) => Array.from({ length: n }).map((o, r) => r))
    ),
    t
  ), { topItemCount: e };
}, X(_t));
function Kn(t) {
  let e = !1, n;
  return () => (e || (e = !0, n = t()), n);
}
const qo = Kn(() => /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent)), Yo = U(
  ([
    { deviation: t, scrollBy: e, scrollingInProgress: n, scrollTop: o },
    { isAtBottom: r, isScrolling: s, lastJumpDueToItemResize: i, scrollDirection: l },
    { listState: c },
    { beforeUnshiftWith: a, gap: p, shiftWithOffset: I, sizes: h },
    { log: f },
    { recalcInProgress: C }
  ]) => {
    const w = ht(
      x(
        c,
        _(i),
        Rt(
          ([, m, u, T], [{ bottom: R, items: g, offsetBottom: d, totalCount: b }, k]) => {
            const F = R + d;
            let L = 0;
            return u === b && m.length > 0 && g.length > 0 && (g[0].originalIndex === 0 && m[0].originalIndex === 0 || (L = F - T, L !== 0 && (L += k))), [L, g, b, F];
          },
          [0, [], 0, 0]
        ),
        P(([m]) => m !== 0),
        _(o, l, n, r, f, C),
        P(([, m, u, T, , , R]) => !R && !T && m !== 0 && u === le),
        E(([[m], , , , , u]) => (u("Upward scrolling compensation", { amount: m }, mt.DEBUG), m))
      )
    );
    function S(m) {
      m > 0 ? (W(e, { behavior: "auto", top: -m }), W(t, 0)) : (W(t, 0), W(e, { behavior: "auto", top: -m }));
    }
    return K(x(w, _(t, s)), ([m, u, T]) => {
      T && qo() ? W(t, u - m) : S(-m);
    }), K(
      x(
        rt(ct(s, !1), t, C),
        P(([m, u, T]) => !m && !T && u !== 0),
        E(([m, u]) => u),
        Lt(1)
      ),
      S
    ), O(
      x(
        I,
        E((m) => ({ top: -m }))
      ),
      e
    ), K(
      x(
        a,
        _(h, p),
        E(([m, { groupIndices: u, lastSize: T, sizeTree: R }, g]) => {
          function d(b) {
            return b * (T + g);
          }
          if (u.length === 0)
            return d(m);
          {
            let b = 0;
            const k = re(R, 0);
            let F = 0, L = 0;
            for (; F < m; ) {
              F++, b += k;
              let V = u.length === L + 1 ? 1 / 0 : u[L + 1] - u[L] - 1;
              F + V > m && (b -= k, V = m - F + 1), F += V, b += d(V), L++;
            }
            return b;
          }
        })
      ),
      (m) => {
        W(t, m), requestAnimationFrame(() => {
          W(e, { top: m }), requestAnimationFrame(() => {
            W(t, 0), W(C, !1);
          });
        });
      }
    ), { deviation: t };
  },
  X(at, ae, _t, Et, Vt, Ne)
), Zo = U(
  ([
    t,
    e,
    n,
    o,
    r,
    s,
    i,
    l,
    c,
    a
  ]) => ({
    ...t,
    ...e,
    ...n,
    ...o,
    ...r,
    ...s,
    ...i,
    ...l,
    ...c,
    ...a
  }),
  X(
    Ke,
    _o,
    Pt,
    Un,
    $n,
    No,
    Mo,
    je,
    $o,
    Vt
  )
), jn = U(
  ([
    {
      data: t,
      defaultItemSize: e,
      firstItemIndex: n,
      fixedItemSize: o,
      gap: r,
      groupIndices: s,
      itemSize: i,
      sizeRanges: l,
      sizes: c,
      statefulTotalCount: a,
      totalCount: p,
      trackItemSizes: I
    },
    { initialItemFinalLocationReached: h, initialTopMostItemIndex: f, scrolledToInitialItem: C },
    w,
    S,
    m,
    { listState: u, topItemsIndexes: T, ...R },
    { scrollToIndex: g },
    d,
    { topItemCount: b },
    { groupCounts: k },
    F
  ]) => (O(R.rangeChanged, F.scrollSeekRangeChanged), O(
    x(
      F.windowViewportRect,
      E((L) => L.visibleHeight)
    ),
    w.viewportHeight
  ), {
    data: t,
    defaultItemHeight: e,
    firstItemIndex: n,
    fixedItemHeight: o,
    gap: r,
    groupCounts: k,
    initialItemFinalLocationReached: h,
    initialTopMostItemIndex: f,
    scrolledToInitialItem: C,
    sizeRanges: l,
    topItemCount: b,
    topItemsIndexes: T,
    // input
    totalCount: p,
    ...m,
    groupIndices: s,
    itemSize: i,
    listState: u,
    scrollToIndex: g,
    // output
    statefulTotalCount: a,
    trackItemSizes: I,
    // exported from stateFlagsSystem
    ...R,
    // the bag of IO from featureGroup1System
    ...F,
    ...w,
    sizes: c,
    ...S
  }),
  X(
    Et,
    ue,
    at,
    Uo,
    Go,
    _t,
    ce,
    Yo,
    jo,
    Gn,
    Zo
  )
);
function Xo(t, e) {
  const n = {}, o = {};
  let r = 0;
  const s = t.length;
  for (; r < s; )
    o[t[r]] = 1, r += 1;
  for (const i in e)
    Object.hasOwn(o, i) || (n[i] = e[i]);
  return n;
}
const pe = typeof document < "u" ? H.useLayoutEffect : H.useEffect;
function qe(t, e, n) {
  const o = Object.keys(e.required || {}), r = Object.keys(e.optional || {}), s = Object.keys(e.methods || {}), i = Object.keys(e.events || {}), l = H.createContext({});
  function c(m, u) {
    m.propsReady && W(m.propsReady, !1);
    for (const T of o) {
      const R = m[e.required[T]];
      W(R, u[T]);
    }
    for (const T of r)
      if (T in u) {
        const R = m[e.optional[T]];
        W(R, u[T]);
      }
    m.propsReady && W(m.propsReady, !0);
  }
  function a(m) {
    return s.reduce((u, T) => (u[T] = (R) => {
      const g = m[e.methods[T]];
      W(g, R);
    }, u), {});
  }
  function p(m) {
    return i.reduce((u, T) => (u[T] = mo(m[e.events[T]]), u), {});
  }
  const I = H.forwardRef((m, u) => {
    const { children: T, ...R } = m, [g] = H.useState(() => ve(ho(t), (k) => {
      c(k, R);
    })), [d] = H.useState(cn(p, g));
    pe(() => {
      for (const k of i)
        k in R && K(d[k], R[k]);
      return () => {
        Object.values(d).map(We);
      };
    }, [R, d, g]), pe(() => {
      c(g, R);
    }), H.useImperativeHandle(u, ln(a(g)));
    const b = n;
    return /* @__PURE__ */ z(l.Provider, { value: g, children: n ? /* @__PURE__ */ z(b, { ...Xo([...o, ...r, ...i], R), children: T }) : T });
  }), h = (m) => {
    const u = H.useContext(l);
    return H.useCallback(
      (T) => {
        W(u[m], T);
      },
      [u, m]
    );
  }, f = (m) => {
    const T = H.useContext(l)[m], R = H.useCallback(
      (g) => K(T, g),
      [T]
    );
    return H.useSyncExternalStore(
      R,
      () => st(T),
      () => st(T)
    );
  }, C = (m) => {
    const T = H.useContext(l)[m], [R, g] = H.useState(cn(st, T));
    return pe(
      () => K(T, (d) => {
        d !== R && g(ln(d));
      }),
      [T, R]
    ), R;
  }, w = H.version.startsWith("18") ? f : C;
  return {
    Component: I,
    useEmitter: (m, u) => {
      const R = H.useContext(l)[m];
      pe(() => K(R, u), [u, R]);
    },
    useEmitterValue: w,
    usePublisher: h
  };
}
const be = H.createContext(void 0), qn = H.createContext(void 0), Yn = typeof document < "u" ? H.useLayoutEffect : H.useEffect;
function ke(t) {
  return "self" in t;
}
function Jo(t) {
  return "body" in t;
}
function Zn(t, e, n, o = Yt, r, s) {
  const i = H.useRef(null), l = H.useRef(null), c = H.useRef(null), a = H.useCallback(
    (h) => {
      let f, C, w;
      const S = h.target;
      if (Jo(S) || ke(S)) {
        const u = ke(S) ? S : S.defaultView;
        w = s ? u.scrollX : u.scrollY, f = s ? u.document.documentElement.scrollWidth : u.document.documentElement.scrollHeight, C = s ? u.innerWidth : u.innerHeight;
      } else
        w = s ? S.scrollLeft : S.scrollTop, f = s ? S.scrollWidth : S.scrollHeight, C = s ? S.offsetWidth : S.offsetHeight;
      const m = () => {
        t({
          scrollHeight: f,
          scrollTop: Math.max(w, 0),
          viewportHeight: C
        });
      };
      h.suppressFlushSync ? m() : io.flushSync(m), l.current !== null && (w === l.current || w <= 0 || w === f - C) && (l.current = null, e(!0), c.current && (clearTimeout(c.current), c.current = null));
    },
    [t, e, s]
  );
  H.useEffect(() => {
    const h = r || i.current;
    return o(r || i.current), a({ suppressFlushSync: !0, target: h }), h.addEventListener("scroll", a, { passive: !0 }), () => {
      o(null), h.removeEventListener("scroll", a);
    };
  }, [i, a, n, o, r]);
  function p(h) {
    const f = i.current;
    if (!f || (s ? "offsetWidth" in f && f.offsetWidth === 0 : "offsetHeight" in f && f.offsetHeight === 0))
      return;
    const C = h.behavior === "smooth";
    let w, S, m;
    ke(f) ? (S = Math.max(
      wt(f.document.documentElement, s ? "width" : "height"),
      s ? f.document.documentElement.scrollWidth : f.document.documentElement.scrollHeight
    ), w = s ? f.innerWidth : f.innerHeight, m = s ? window.scrollX : window.scrollY) : (S = f[s ? "scrollWidth" : "scrollHeight"], w = wt(f, s ? "width" : "height"), m = f[s ? "scrollLeft" : "scrollTop"]);
    const u = S - w;
    if (h.top = Math.ceil(Math.max(Math.min(u, h.top), 0)), Nn(w, S) || h.top === m) {
      t({ scrollHeight: S, scrollTop: m, viewportHeight: w }), C && e(!0);
      return;
    }
    C ? (l.current = h.top, c.current && clearTimeout(c.current), c.current = setTimeout(() => {
      c.current = null, l.current = null, e(!0);
    }, 1e3)) : l.current = null, s && (h = { behavior: h.behavior, left: h.top }), f.scrollTo(h);
  }
  function I(h) {
    s && (h = { behavior: h.behavior, left: h.top }), i.current.scrollBy(h);
  }
  return { scrollByCallback: I, scrollerRef: i, scrollToCallback: p };
}
const Fe = "-webkit-sticky", xn = "sticky", Xn = Kn(() => {
  if (typeof document > "u")
    return xn;
  const t = document.createElement("div");
  return t.style.position = Fe, t.style.position === Fe ? Fe : xn;
});
function Ye(t) {
  return t;
}
const Qo = /* @__PURE__ */ U(() => {
  const t = v((c) => `Item ${c}`), e = v(null), n = v((c) => `Group ${c}`), o = v({}), r = v(Ye), s = v("div"), i = v(Yt), l = (c, a = null) => ct(
    x(
      o,
      E((p) => p[c]),
      Y()
    ),
    a
  );
  return {
    components: o,
    computeItemKey: r,
    context: e,
    EmptyPlaceholder: l("EmptyPlaceholder"),
    FooterComponent: l("Footer"),
    GroupComponent: l("Group", "div"),
    groupContent: n,
    HeaderComponent: l("Header"),
    HeaderFooterTag: s,
    ItemComponent: l("Item", "div"),
    itemContent: t,
    ListComponent: l("List", "div"),
    ScrollerComponent: l("Scroller", "div"),
    scrollerRef: i,
    ScrollSeekPlaceholder: l("ScrollSeekPlaceholder"),
    TopItemListComponent: l("TopItemList")
  };
}), tr = /* @__PURE__ */ U(
  ([t, e]) => ({ ...t, ...e }),
  X(jn, Qo)
), er = ({ height: t }) => /* @__PURE__ */ z("div", { style: { height: t } }), nr = { overflowAnchor: "none", position: Xn(), zIndex: 1 }, Jn = { overflowAnchor: "none" }, or = { ...Jn, display: "inline-block", height: "100%" }, Tn = /* @__PURE__ */ H.memo(function({ showTopList: e = !1 }) {
  const n = M("listState"), o = gt("sizeRanges"), r = M("useWindowScroll"), s = M("customScrollParent"), i = gt("windowScrollContainerState"), l = gt("scrollContainerState"), c = s || r ? i : l, a = M("itemContent"), p = M("context"), I = M("groupContent"), h = M("trackItemSizes"), f = M("itemSize"), C = M("log"), w = gt("gap"), S = M("horizontalDirection"), { callbackRef: m } = kn(
    o,
    f,
    h,
    e ? Yt : c,
    C,
    w,
    s,
    S,
    M("skipAnimationFrameInResizeObserver")
  ), [u, T] = H.useState(0);
  Je("deviation", (B) => {
    u !== B && T(B);
  });
  const R = M("EmptyPlaceholder"), g = M("ScrollSeekPlaceholder") || er, d = M("ListComponent"), b = M("ItemComponent"), k = M("GroupComponent"), F = M("computeItemKey"), L = M("isSeeking"), V = M("groupIndices").length > 0, D = M("alignToBottom"), J = M("initialItemFinalLocationReached"), nt = e ? {} : {
    boxSizing: "border-box",
    ...S ? {
      display: "inline-block",
      height: "100%",
      marginLeft: u !== 0 ? u : D ? "auto" : 0,
      paddingLeft: n.offsetTop,
      paddingRight: n.offsetBottom,
      whiteSpace: "nowrap"
    } : {
      marginTop: u !== 0 ? u : D ? "auto" : 0,
      paddingBottom: n.offsetBottom,
      paddingTop: n.offsetTop
    },
    ...J ? {} : { visibility: "hidden" }
  };
  return !e && n.totalCount === 0 && R ? /* @__PURE__ */ z(R, { ...Z(R, p) }) : /* @__PURE__ */ z(
    d,
    {
      ...Z(d, p),
      "data-testid": e ? "virtuoso-top-item-list" : "virtuoso-item-list",
      ref: m,
      style: nt,
      children: (e ? n.topItems : n.items).map((B) => {
        const q = B.originalIndex, it = F(q + n.firstItemIndex, B.data, p);
        return L ? /* @__PURE__ */ $t(
          g,
          {
            ...Z(g, p),
            height: B.size,
            index: B.index,
            key: it,
            type: B.type || "item",
            ...B.type === "group" ? {} : { groupIndex: B.groupIndex }
          }
        ) : B.type === "group" ? /* @__PURE__ */ $t(
          k,
          {
            ...Z(k, p),
            "data-index": q,
            "data-item-index": B.index,
            "data-known-size": B.size,
            key: it,
            style: nr
          },
          I(B.index, p)
        ) : /* @__PURE__ */ $t(
          b,
          {
            ...Z(b, p),
            ...Qn(b, B.data),
            "data-index": q,
            "data-item-group-index": B.groupIndex,
            "data-item-index": B.index,
            "data-known-size": B.size,
            key: it,
            style: S ? or : Jn
          },
          V ? a(B.index, B.groupIndex, B.data, p) : a(B.index, B.data, p)
        );
      })
    }
  );
}), rr = {
  height: "100%",
  outline: "none",
  overflowY: "auto",
  position: "relative",
  WebkitOverflowScrolling: "touch"
}, sr = {
  outline: "none",
  overflowX: "auto",
  position: "relative"
}, Zt = (t) => ({
  height: "100%",
  position: "absolute",
  top: 0,
  width: "100%",
  ...t ? { display: "flex", flexDirection: "column" } : {}
}), ir = {
  position: Xn(),
  top: 0,
  width: "100%",
  zIndex: 1
};
function Z(t, e) {
  if (typeof t != "string")
    return { context: e };
}
function Qn(t, e) {
  return { item: typeof t == "string" ? void 0 : e };
}
const lr = /* @__PURE__ */ H.memo(function() {
  const e = M("HeaderComponent"), n = gt("headerHeight"), o = M("HeaderFooterTag"), r = Ht(
    H.useMemo(
      () => (i) => {
        n(wt(i, "height"));
      },
      [n]
    ),
    !0,
    M("skipAnimationFrameInResizeObserver")
  ), s = M("context");
  return e ? /* @__PURE__ */ z(o, { ref: r, children: /* @__PURE__ */ z(e, { ...Z(e, s) }) }) : null;
}), cr = /* @__PURE__ */ H.memo(function() {
  const e = M("FooterComponent"), n = gt("footerHeight"), o = M("HeaderFooterTag"), r = Ht(
    H.useMemo(
      () => (i) => {
        n(wt(i, "height"));
      },
      [n]
    ),
    !0,
    M("skipAnimationFrameInResizeObserver")
  ), s = M("context");
  return e ? /* @__PURE__ */ z(o, { ref: r, children: /* @__PURE__ */ z(e, { ...Z(e, s) }) }) : null;
});
function Ze({ useEmitter: t, useEmitterValue: e, usePublisher: n }) {
  return H.memo(function({ children: s, style: i, ...l }) {
    const c = n("scrollContainerState"), a = e("ScrollerComponent"), p = n("smoothScrollTargetReached"), I = e("scrollerRef"), h = e("context"), f = e("horizontalDirection") || !1, { scrollByCallback: C, scrollerRef: w, scrollToCallback: S } = Zn(
      c,
      p,
      a,
      I,
      void 0,
      f
    );
    return t("scrollTo", S), t("scrollBy", C), /* @__PURE__ */ z(
      a,
      {
        "data-testid": "virtuoso-scroller",
        "data-virtuoso-scroller": !0,
        ref: w,
        style: { ...f ? sr : rr, ...i },
        tabIndex: 0,
        ...l,
        ...Z(a, h),
        children: s
      }
    );
  });
}
function Xe({ useEmitter: t, useEmitterValue: e, usePublisher: n }) {
  return H.memo(function({ children: s, style: i, ...l }) {
    const c = n("windowScrollContainerState"), a = e("ScrollerComponent"), p = n("smoothScrollTargetReached"), I = e("totalListHeight"), h = e("deviation"), f = e("customScrollParent"), C = e("context"), w = H.useRef(null), S = e("scrollerRef"), { scrollByCallback: m, scrollerRef: u, scrollToCallback: T } = Zn(
      c,
      p,
      a,
      S,
      f
    );
    return Yn(() => {
      var R;
      return u.current = f || ((R = w.current) == null ? void 0 : R.ownerDocument.defaultView), () => {
        u.current = null;
      };
    }, [u, f]), t("windowScrollTo", T), t("scrollBy", m), /* @__PURE__ */ z(
      a,
      {
        ref: w,
        "data-virtuoso-scroller": !0,
        style: { position: "relative", ...i, ...I !== 0 ? { height: I + h } : {} },
        ...l,
        ...Z(a, C),
        children: s
      }
    );
  });
}
const ur = ({ children: t }) => {
  const e = H.useContext(be), n = gt("viewportHeight"), o = gt("fixedItemHeight"), r = M("alignToBottom"), s = M("horizontalDirection"), i = H.useMemo(
    () => ne(n, (c) => wt(c, s ? "width" : "height")),
    [n, s]
  ), l = Ht(i, !0, M("skipAnimationFrameInResizeObserver"));
  return H.useEffect(() => {
    e && (n(e.viewportHeight), o(e.itemHeight));
  }, [e, n, o]), /* @__PURE__ */ z("div", { "data-viewport-type": "element", ref: l, style: Zt(r), children: t });
}, ar = ({ children: t }) => {
  const e = H.useContext(be), n = gt("windowViewportRect"), o = gt("fixedItemHeight"), r = M("customScrollParent"), s = _e(
    n,
    r,
    M("skipAnimationFrameInResizeObserver")
  ), i = M("alignToBottom");
  return H.useEffect(() => {
    e && (o(e.itemHeight), n({ offsetTop: 0, visibleHeight: e.viewportHeight, visibleWidth: 100 }));
  }, [e, n, o]), /* @__PURE__ */ z("div", { "data-viewport-type": "window", ref: s, style: Zt(i), children: t });
}, dr = ({ children: t }) => {
  const e = M("TopItemListComponent") || "div", n = M("headerHeight"), o = { ...ir, marginTop: `${n}px` }, r = M("context");
  return /* @__PURE__ */ z(e, { style: o, ...Z(e, r), children: t });
}, fr = /* @__PURE__ */ H.memo(function(e) {
  const n = M("useWindowScroll"), o = M("topItemsIndexes").length > 0, r = M("customScrollParent"), s = M("context"), i = r || n ? pr : mr, l = r || n ? ar : ur;
  return /* @__PURE__ */ Kt(i, { ...e, ...Z(i, s), children: [
    o && /* @__PURE__ */ z(dr, { children: /* @__PURE__ */ z(Tn, { showTopList: !0 }) }),
    /* @__PURE__ */ Kt(l, { children: [
      /* @__PURE__ */ z(lr, {}),
      /* @__PURE__ */ z(Tn, {}),
      /* @__PURE__ */ z(cr, {})
    ] })
  ] });
}), {
  Component: to,
  useEmitter: Je,
  useEmitterValue: M,
  usePublisher: gt
} = /* @__PURE__ */ qe(
  tr,
  {
    required: {},
    optional: {
      restoreStateFrom: "restoreStateFrom",
      context: "context",
      followOutput: "followOutput",
      itemContent: "itemContent",
      groupContent: "groupContent",
      overscan: "overscan",
      increaseViewportBy: "increaseViewportBy",
      totalCount: "totalCount",
      groupCounts: "groupCounts",
      topItemCount: "topItemCount",
      firstItemIndex: "firstItemIndex",
      initialTopMostItemIndex: "initialTopMostItemIndex",
      components: "components",
      atBottomThreshold: "atBottomThreshold",
      atTopThreshold: "atTopThreshold",
      computeItemKey: "computeItemKey",
      defaultItemHeight: "defaultItemHeight",
      fixedItemHeight: "fixedItemHeight",
      itemSize: "itemSize",
      scrollSeekConfiguration: "scrollSeekConfiguration",
      headerFooterTag: "HeaderFooterTag",
      data: "data",
      initialItemCount: "initialItemCount",
      initialScrollTop: "initialScrollTop",
      alignToBottom: "alignToBottom",
      useWindowScroll: "useWindowScroll",
      customScrollParent: "customScrollParent",
      scrollerRef: "scrollerRef",
      logLevel: "logLevel",
      horizontalDirection: "horizontalDirection",
      skipAnimationFrameInResizeObserver: "skipAnimationFrameInResizeObserver"
    },
    methods: {
      scrollToIndex: "scrollToIndex",
      scrollIntoView: "scrollIntoView",
      scrollTo: "scrollTo",
      scrollBy: "scrollBy",
      autoscrollToBottom: "autoscrollToBottom",
      getState: "getState"
    },
    events: {
      isScrolling: "isScrolling",
      endReached: "endReached",
      startReached: "startReached",
      rangeChanged: "rangeChanged",
      atBottomStateChange: "atBottomStateChange",
      atTopStateChange: "atTopStateChange",
      totalListHeightChanged: "totalListHeightChanged",
      itemsRendered: "itemsRendered",
      groupIndices: "groupIndices"
    }
  },
  fr
), mr = /* @__PURE__ */ Ze({ useEmitter: Je, useEmitterValue: M, usePublisher: gt }), pr = /* @__PURE__ */ Xe({ useEmitter: Je, useEmitterValue: M, usePublisher: gt }), Kr = to, jr = to, hr = /* @__PURE__ */ U(() => {
  const t = v((c) => /* @__PURE__ */ Kt("td", { children: [
    "Item $",
    c
  ] })), e = v(null), n = v(null), o = v(null), r = v({}), s = v(Ye), i = v(Yt), l = (c, a = null) => ct(
    x(
      r,
      E((p) => p[c]),
      Y()
    ),
    a
  );
  return {
    components: r,
    computeItemKey: s,
    context: e,
    EmptyPlaceholder: l("EmptyPlaceholder"),
    FillerRow: l("FillerRow"),
    fixedFooterContent: o,
    fixedHeaderContent: n,
    itemContent: t,
    ScrollerComponent: l("Scroller", "div"),
    scrollerRef: i,
    ScrollSeekPlaceholder: l("ScrollSeekPlaceholder"),
    TableBodyComponent: l("TableBody", "tbody"),
    TableComponent: l("Table", "table"),
    TableFooterComponent: l("TableFoot", "tfoot"),
    TableHeadComponent: l("TableHead", "thead"),
    TableRowComponent: l("TableRow", "tr")
  };
}), gr = /* @__PURE__ */ U(
  ([t, e]) => ({ ...t, ...e }),
  X(jn, hr)
), Ir = ({ height: t }) => /* @__PURE__ */ z("tr", { children: /* @__PURE__ */ z("td", { style: { height: t } }) }), Sr = ({ height: t }) => /* @__PURE__ */ z("tr", { children: /* @__PURE__ */ z("td", { style: { border: 0, height: t, padding: 0 } }) }), xr = { overflowAnchor: "none" }, Cn = /* @__PURE__ */ H.memo(function({ showTopList: e = !1 }) {
  const n = G("listState"), o = G("computeItemKey"), r = G("firstItemIndex"), s = G("isSeeking"), i = G("ScrollSeekPlaceholder") || Ir, l = G("context"), c = G("TableRowComponent"), a = G("fixedHeaderHeight"), p = G("itemContent"), I = (e ? n.topItems : []).reduce((f, C, w) => (w === 0 ? f.push(C.size) : f.push(f[w - 1] + C.size), f), []), h = (e ? n.topItems : n.items).map((f) => {
    const C = f.originalIndex, w = o(C + r, f.data, l), S = e ? C === 0 ? 0 : I[C - 1] : 0;
    return s ? /* @__PURE__ */ $t(
      i,
      {
        ...Z(i, l),
        height: f.size,
        index: f.index,
        key: w,
        type: f.type || "item"
      }
    ) : /* @__PURE__ */ $t(
      c,
      {
        ...Z(c, l),
        ...Qn(c, f.data),
        "data-index": C,
        "data-item-index": f.index,
        "data-known-size": f.size,
        key: w,
        style: e ? { overflowAnchor: "none", position: "sticky", top: a + S, zIndex: 2 } : xr
      },
      p(f.index, f.data, l)
    );
  });
  return /* @__PURE__ */ z(so, { children: h });
}), Tr = /* @__PURE__ */ H.memo(function() {
  const e = G("listState"), n = G("topItemsIndexes").length > 0, o = Tt("sizeRanges"), r = G("useWindowScroll"), s = G("customScrollParent"), i = Tt("windowScrollContainerState"), l = Tt("scrollContainerState"), c = s || r ? i : l, a = G("trackItemSizes"), p = G("itemSize"), I = G("log"), { callbackRef: h, ref: f } = kn(
    o,
    p,
    a,
    c,
    I,
    void 0,
    s,
    !1,
    G("skipAnimationFrameInResizeObserver")
  ), [C, w] = H.useState(0);
  Qe("deviation", (V) => {
    C !== V && (f.current.style.marginTop = `${V}px`, w(V));
  });
  const S = G("EmptyPlaceholder"), m = G("FillerRow") || Sr, u = G("TableBodyComponent"), T = G("paddingTopAddition"), R = G("statefulTotalCount"), g = G("context");
  if (R === 0 && S)
    return /* @__PURE__ */ z(S, { ...Z(S, g) });
  const d = (n ? e.topItems : []).reduce((V, D) => V + D.size, 0), b = e.offsetTop + T + C - d, k = e.offsetBottom, F = b > 0 ? /* @__PURE__ */ z(m, { context: g, height: b }, "padding-top") : null, L = k > 0 ? /* @__PURE__ */ z(m, { context: g, height: k }, "padding-bottom") : null;
  return /* @__PURE__ */ Kt(u, { "data-testid": "virtuoso-item-list", ref: h, ...Z(u, g), children: [
    F,
    n && /* @__PURE__ */ z(Cn, { showTopList: !0 }),
    /* @__PURE__ */ z(Cn, {}),
    L
  ] });
}), Cr = ({ children: t }) => {
  const e = H.useContext(be), n = Tt("viewportHeight"), o = Tt("fixedItemHeight"), r = Ht(
    H.useMemo(() => ne(n, (s) => wt(s, "height")), [n]),
    !0,
    G("skipAnimationFrameInResizeObserver")
  );
  return H.useEffect(() => {
    e && (n(e.viewportHeight), o(e.itemHeight));
  }, [e, n, o]), /* @__PURE__ */ z("div", { "data-viewport-type": "element", ref: r, style: Zt(!1), children: t });
}, wr = ({ children: t }) => {
  const e = H.useContext(be), n = Tt("windowViewportRect"), o = Tt("fixedItemHeight"), r = G("customScrollParent"), s = _e(
    n,
    r,
    G("skipAnimationFrameInResizeObserver")
  );
  return H.useEffect(() => {
    e && (o(e.itemHeight), n({ offsetTop: 0, visibleHeight: e.viewportHeight, visibleWidth: 100 }));
  }, [e, n, o]), /* @__PURE__ */ z("div", { "data-viewport-type": "window", ref: s, style: Zt(!1), children: t });
}, vr = /* @__PURE__ */ H.memo(function(e) {
  const n = G("useWindowScroll"), o = G("customScrollParent"), r = Tt("fixedHeaderHeight"), s = Tt("fixedFooterHeight"), i = G("fixedHeaderContent"), l = G("fixedFooterContent"), c = G("context"), a = Ht(
    H.useMemo(() => ne(r, (u) => wt(u, "height")), [r]),
    !0,
    G("skipAnimationFrameInResizeObserver")
  ), p = Ht(
    H.useMemo(() => ne(s, (u) => wt(u, "height")), [s]),
    !0,
    G("skipAnimationFrameInResizeObserver")
  ), I = o || n ? br : Rr, h = o || n ? wr : Cr, f = G("TableComponent"), C = G("TableHeadComponent"), w = G("TableFooterComponent"), S = i ? /* @__PURE__ */ z(
    C,
    {
      ref: a,
      style: { position: "sticky", top: 0, zIndex: 2 },
      ...Z(C, c),
      children: i()
    },
    "TableHead"
  ) : null, m = l ? /* @__PURE__ */ z(
    w,
    {
      ref: p,
      style: { bottom: 0, position: "sticky", zIndex: 1 },
      ...Z(w, c),
      children: l()
    },
    "TableFoot"
  ) : null;
  return /* @__PURE__ */ z(I, { ...e, ...Z(I, c), children: /* @__PURE__ */ z(h, { children: /* @__PURE__ */ Kt(f, { style: { borderSpacing: 0, overflowAnchor: "none" }, ...Z(f, c), children: [
    S,
    /* @__PURE__ */ z(Tr, {}, "TableBody"),
    m
  ] }) }) });
}), {
  Component: yr,
  useEmitter: Qe,
  useEmitterValue: G,
  usePublisher: Tt
} = /* @__PURE__ */ qe(
  gr,
  {
    required: {},
    optional: {
      restoreStateFrom: "restoreStateFrom",
      context: "context",
      followOutput: "followOutput",
      firstItemIndex: "firstItemIndex",
      itemContent: "itemContent",
      fixedHeaderContent: "fixedHeaderContent",
      fixedFooterContent: "fixedFooterContent",
      overscan: "overscan",
      increaseViewportBy: "increaseViewportBy",
      totalCount: "totalCount",
      topItemCount: "topItemCount",
      initialTopMostItemIndex: "initialTopMostItemIndex",
      components: "components",
      groupCounts: "groupCounts",
      atBottomThreshold: "atBottomThreshold",
      atTopThreshold: "atTopThreshold",
      computeItemKey: "computeItemKey",
      defaultItemHeight: "defaultItemHeight",
      fixedItemHeight: "fixedItemHeight",
      itemSize: "itemSize",
      scrollSeekConfiguration: "scrollSeekConfiguration",
      data: "data",
      initialItemCount: "initialItemCount",
      initialScrollTop: "initialScrollTop",
      alignToBottom: "alignToBottom",
      useWindowScroll: "useWindowScroll",
      customScrollParent: "customScrollParent",
      scrollerRef: "scrollerRef",
      logLevel: "logLevel"
    },
    methods: {
      scrollToIndex: "scrollToIndex",
      scrollIntoView: "scrollIntoView",
      scrollTo: "scrollTo",
      scrollBy: "scrollBy",
      getState: "getState"
    },
    events: {
      isScrolling: "isScrolling",
      endReached: "endReached",
      startReached: "startReached",
      rangeChanged: "rangeChanged",
      atBottomStateChange: "atBottomStateChange",
      atTopStateChange: "atTopStateChange",
      totalListHeightChanged: "totalListHeightChanged",
      itemsRendered: "itemsRendered",
      groupIndices: "groupIndices"
    }
  },
  vr
), Rr = /* @__PURE__ */ Ze({ useEmitter: Qe, useEmitterValue: G, usePublisher: Tt }), br = /* @__PURE__ */ Xe({ useEmitter: Qe, useEmitterValue: G, usePublisher: Tt }), qr = yr, wn = {
  bottom: 0,
  itemHeight: 0,
  items: [],
  itemWidth: 0,
  offsetBottom: 0,
  offsetTop: 0,
  top: 0
}, Hr = {
  bottom: 0,
  itemHeight: 0,
  items: [{ index: 0 }],
  itemWidth: 0,
  offsetBottom: 0,
  offsetTop: 0,
  top: 0
}, { ceil: vn, floor: Ce, max: ee, min: Oe, round: yn } = Math;
function Rn(t, e, n) {
  return Array.from({ length: e - t + 1 }).map((o, r) => ({ data: n === null ? null : n[r + t], index: r + t }));
}
function Er(t) {
  return {
    ...Hr,
    items: t
  };
}
function he(t, e) {
  return t && t.width === e.width && t.height === e.height;
}
function Br(t, e) {
  return t && t.column === e.column && t.row === e.row;
}
const kr = /* @__PURE__ */ U(
  ([
    { increaseViewportBy: t, listBoundary: e, overscan: n, visibleRange: o },
    { footerHeight: r, headerHeight: s, scrollBy: i, scrollContainerState: l, scrollTo: c, scrollTop: a, smoothScrollTargetReached: p, viewportHeight: I },
    h,
    f,
    { didMount: C, propsReady: w },
    { customScrollParent: S, useWindowScroll: m, windowScrollContainerState: u, windowScrollTo: T, windowViewportRect: R },
    g
  ]) => {
    const d = v(0), b = v(0), k = v(wn), F = v({ height: 0, width: 0 }), L = v({ height: 0, width: 0 }), V = $(), D = $(), J = v(0), nt = v(null), B = v({ column: 0, row: 0 }), q = $(), it = $(), dt = v(!1), St = v(0), ft = v(!0), ut = v(!1), At = v(!1);
    K(
      x(
        C,
        _(St),
        P(([y, N]) => !!N)
      ),
      () => {
        W(ft, !1);
      }
    ), K(
      x(
        rt(C, ft, L, F, St, ut),
        P(([y, N, Q, lt, , tt]) => y && !N && Q.height !== 0 && lt.height !== 0 && !tt)
      ),
      ([, , , , y]) => {
        W(ut, !0), $e(1, () => {
          W(V, y);
        }), bt(x(a), () => {
          W(e, [0, 0]), W(ft, !0);
        });
      }
    ), O(
      x(
        it,
        P((y) => y != null && y.scrollTop > 0),
        yt(0)
      ),
      b
    ), K(
      x(
        C,
        _(it),
        P(([, y]) => y != null)
      ),
      ([, y]) => {
        y && (W(F, y.viewport), W(L, y.item), W(B, y.gap), y.scrollTop > 0 && (W(dt, !0), bt(x(a, jt(1)), (N) => {
          W(dt, !1);
        }), W(c, { top: y.scrollTop })));
      }
    ), O(
      x(
        F,
        E(({ height: y }) => y)
      ),
      I
    ), O(
      x(
        rt(
          A(F, he),
          A(L, he),
          A(B, (y, N) => y && y.column === N.column && y.row === N.row),
          A(a)
        ),
        E(([y, N, Q, lt]) => ({
          gap: Q,
          item: N,
          scrollTop: lt,
          viewport: y
        }))
      ),
      q
    ), O(
      x(
        rt(
          A(d),
          o,
          A(B, Br),
          A(L, he),
          A(F, he),
          A(nt),
          A(b),
          A(dt),
          A(ft),
          A(St)
        ),
        P(([, , , , , , , y]) => !y),
        E(
          ([
            y,
            [N, Q],
            lt,
            tt,
            kt,
            Jt,
            Nt,
            ,
            de,
            Ft
          ]) => {
            const { column: Ot, row: Qt } = lt, { height: fe, width: He } = tt, { width: tn } = kt;
            if (Nt === 0 && (y === 0 || tn === 0))
              return wn;
            if (He === 0) {
              const sn = Ue(Ft, y), ro = sn + Math.max(Nt - 1, 0);
              return Er(Rn(sn, ro, Jt));
            }
            const me = eo(tn, He, Ot);
            let Dt, Wt;
            de ? N === 0 && Q === 0 && Nt > 0 ? (Dt = 0, Wt = Nt - 1) : (Dt = me * Ce((N + Qt) / (fe + Qt)), Wt = me * vn((Q + Qt) / (fe + Qt)) - 1, Wt = Oe(y - 1, ee(Wt, me - 1)), Dt = Oe(Wt, ee(0, Dt))) : (Dt = 0, Wt = -1);
            const en = Rn(Dt, Wt, Jt), { bottom: nn, top: on } = bn(kt, lt, tt, en), rn = vn(y / me), oo = rn * fe + (rn - 1) * Qt - nn;
            return { bottom: nn, itemHeight: fe, items: en, itemWidth: He, offsetBottom: oo, offsetTop: on, top: on };
          }
        )
      ),
      k
    ), O(
      x(
        nt,
        P((y) => y !== null),
        E((y) => y.length)
      ),
      d
    ), O(
      x(
        rt(F, L, k, B),
        P(([y, N, { items: Q }]) => Q.length > 0 && N.height !== 0 && y.height !== 0),
        E(([y, N, { items: Q }, lt]) => {
          const { bottom: tt, top: kt } = bn(y, lt, N, Q);
          return [kt, tt];
        }),
        Y(se)
      ),
      e
    );
    const xt = v(!1);
    O(
      x(
        a,
        _(xt),
        E(([y, N]) => N || y !== 0)
      ),
      xt
    );
    const Xt = ht(
      x(
        rt(k, d),
        P(([{ items: y }]) => y.length > 0),
        _(xt),
        P(([[y, N], Q]) => {
          const tt = y.items[y.items.length - 1].index === N - 1;
          return (Q || y.bottom > 0 && y.itemHeight > 0 && y.offsetBottom === 0 && y.items.length === N) && tt;
        }),
        E(([[, y]]) => y - 1),
        Y()
      )
    ), Mt = ht(
      x(
        A(k),
        P(({ items: y }) => y.length > 0 && y[0].index === 0),
        yt(0),
        Y()
      )
    ), vt = ht(
      x(
        A(k),
        _(dt),
        P(([{ items: y }, N]) => y.length > 0 && !N),
        E(([{ items: y }]) => ({
          endIndex: y[y.length - 1].index,
          startIndex: y[0].index
        })),
        Y(Pn),
        Lt(0)
      )
    );
    O(vt, f.scrollSeekRangeChanged), O(
      x(
        V,
        _(F, L, d, B),
        E(([y, N, Q, lt, tt]) => {
          const kt = _n(y), { align: Jt, behavior: Nt, offset: de } = kt;
          let Ft = kt.index;
          Ft === "LAST" && (Ft = lt - 1), Ft = ee(0, Ft, Oe(lt - 1, Ft));
          let Ot = Ae(N, tt, Q, Ft);
          return Jt === "end" ? Ot = yn(Ot - N.height + Q.height) : Jt === "center" && (Ot = yn(Ot - N.height / 2 + Q.height / 2)), de && (Ot += de), { behavior: Nt, top: Ot };
        })
      ),
      c
    );
    const Bt = ct(
      x(
        k,
        E((y) => y.offsetBottom + y.bottom)
      ),
      0
    );
    return O(
      x(
        R,
        E((y) => ({ height: y.visibleHeight, width: y.visibleWidth }))
      ),
      F
    ), {
      customScrollParent: S,
      // input
      data: nt,
      deviation: J,
      footerHeight: r,
      gap: B,
      headerHeight: s,
      increaseViewportBy: t,
      initialItemCount: b,
      itemDimensions: L,
      overscan: n,
      restoreStateFrom: it,
      scrollBy: i,
      scrollContainerState: l,
      scrollHeight: D,
      scrollTo: c,
      scrollToIndex: V,
      scrollTop: a,
      smoothScrollTargetReached: p,
      totalCount: d,
      useWindowScroll: m,
      viewportDimensions: F,
      windowScrollContainerState: u,
      windowScrollTo: T,
      windowViewportRect: R,
      ...f,
      // output
      gridState: k,
      horizontalDirection: At,
      initialTopMostItemIndex: St,
      totalListHeight: Bt,
      ...h,
      endReached: Xt,
      propsReady: w,
      rangeChanged: vt,
      startReached: Mt,
      stateChanged: q,
      stateRestoreInProgress: dt,
      ...g
    };
  },
  X(Ke, at, ae, Un, Pt, je, Vt)
);
function eo(t, e, n) {
  return ee(1, Ce((t + n) / (Ce(e) + n)));
}
function bn(t, e, n, o) {
  const { height: r } = n;
  if (r === void 0 || o.length === 0)
    return { bottom: 0, top: 0 };
  const s = Ae(t, e, n, o[0].index);
  return { bottom: Ae(t, e, n, o[o.length - 1].index) + r, top: s };
}
function Ae(t, e, n, o) {
  const r = eo(t.width, n.width, e.column), s = Ce(o / r), i = s * n.height + ee(0, s - 1) * e.row;
  return i > 0 ? i + e.row : i;
}
const Fr = /* @__PURE__ */ U(() => {
  const t = v((I) => `Item ${I}`), e = v({}), n = v(null), o = v("virtuoso-grid-item"), r = v("virtuoso-grid-list"), s = v(Ye), i = v("div"), l = v(Yt), c = (I, h = null) => ct(
    x(
      e,
      E((f) => f[I]),
      Y()
    ),
    h
  ), a = v(!1), p = v(!1);
  return O(A(p), a), {
    components: e,
    computeItemKey: s,
    context: n,
    FooterComponent: c("Footer"),
    HeaderComponent: c("Header"),
    headerFooterTag: i,
    itemClassName: o,
    ItemComponent: c("Item", "div"),
    itemContent: t,
    listClassName: r,
    ListComponent: c("List", "div"),
    readyStateChanged: a,
    reportReadyState: p,
    ScrollerComponent: c("Scroller", "div"),
    scrollerRef: l,
    ScrollSeekPlaceholder: c("ScrollSeekPlaceholder", "div")
  };
}), Or = /* @__PURE__ */ U(
  ([t, e]) => ({ ...t, ...e }),
  X(kr, Fr)
), Lr = /* @__PURE__ */ H.memo(function() {
  const e = et("gridState"), n = et("listClassName"), o = et("itemClassName"), r = et("itemContent"), s = et("computeItemKey"), i = et("isSeeking"), l = It("scrollHeight"), c = et("ItemComponent"), a = et("ListComponent"), p = et("ScrollSeekPlaceholder"), I = et("context"), h = It("itemDimensions"), f = It("gap"), C = et("log"), w = et("stateRestoreInProgress"), S = It("reportReadyState"), m = Ht(
    H.useMemo(
      () => (u) => {
        const T = u.parentElement.parentElement.scrollHeight;
        l(T);
        const R = u.firstChild;
        if (R) {
          const { height: g, width: d } = R.getBoundingClientRect();
          h({ height: g, width: d });
        }
        f({
          column: Hn("column-gap", getComputedStyle(u).columnGap, C),
          row: Hn("row-gap", getComputedStyle(u).rowGap, C)
        });
      },
      [l, h, f, C]
    ),
    !0,
    !1
  );
  return Yn(() => {
    e.itemHeight > 0 && e.itemWidth > 0 && S(!0);
  }, [e]), w ? null : /* @__PURE__ */ z(
    a,
    {
      className: n,
      ref: m,
      ...Z(a, I),
      "data-testid": "virtuoso-item-list",
      style: { paddingBottom: e.offsetBottom, paddingTop: e.offsetTop },
      children: e.items.map((u) => {
        const T = s(u.index, u.data, I);
        return i ? /* @__PURE__ */ z(
          p,
          {
            ...Z(p, I),
            height: e.itemHeight,
            index: u.index,
            width: e.itemWidth
          },
          T
        ) : /* @__PURE__ */ $t(
          c,
          {
            ...Z(c, I),
            className: o,
            "data-index": u.index,
            key: T
          },
          r(u.index, u.data, I)
        );
      })
    }
  );
}), zr = H.memo(function() {
  const e = et("HeaderComponent"), n = It("headerHeight"), o = et("headerFooterTag"), r = Ht(
    H.useMemo(
      () => (i) => {
        n(wt(i, "height"));
      },
      [n]
    ),
    !0,
    !1
  ), s = et("context");
  return e ? /* @__PURE__ */ z(o, { ref: r, children: /* @__PURE__ */ z(e, { ...Z(e, s) }) }) : null;
}), Vr = H.memo(function() {
  const e = et("FooterComponent"), n = It("footerHeight"), o = et("headerFooterTag"), r = Ht(
    H.useMemo(
      () => (i) => {
        n(wt(i, "height"));
      },
      [n]
    ),
    !0,
    !1
  ), s = et("context");
  return e ? /* @__PURE__ */ z(o, { ref: r, children: /* @__PURE__ */ z(e, { ...Z(e, s) }) }) : null;
}), Pr = ({ children: t }) => {
  const e = H.useContext(qn), n = It("itemDimensions"), o = It("viewportDimensions"), r = Ht(
    H.useMemo(
      () => (s) => {
        o(s.getBoundingClientRect());
      },
      [o]
    ),
    !0,
    !1
  );
  return H.useEffect(() => {
    e && (o({ height: e.viewportHeight, width: e.viewportWidth }), n({ height: e.itemHeight, width: e.itemWidth }));
  }, [e, o, n]), /* @__PURE__ */ z("div", { ref: r, style: Zt(!1), children: t });
}, Ar = ({ children: t }) => {
  const e = H.useContext(qn), n = It("windowViewportRect"), o = It("itemDimensions"), r = et("customScrollParent"), s = _e(n, r, !1);
  return H.useEffect(() => {
    e && (o({ height: e.itemHeight, width: e.itemWidth }), n({ offsetTop: 0, visibleHeight: e.viewportHeight, visibleWidth: e.viewportWidth }));
  }, [e, n, o]), /* @__PURE__ */ z("div", { ref: s, style: Zt(!1), children: t });
}, Mr = /* @__PURE__ */ H.memo(function({ ...e }) {
  const n = et("useWindowScroll"), o = et("customScrollParent"), r = o || n ? _r : Gr, s = o || n ? Ar : Pr, i = et("context");
  return /* @__PURE__ */ z(r, { ...e, ...Z(r, i), children: /* @__PURE__ */ Kt(s, { children: [
    /* @__PURE__ */ z(zr, {}),
    /* @__PURE__ */ z(Lr, {}),
    /* @__PURE__ */ z(Vr, {})
  ] }) });
}), {
  Component: Wr,
  useEmitter: no,
  useEmitterValue: et,
  usePublisher: It
} = /* @__PURE__ */ qe(
  Or,
  {
    optional: {
      context: "context",
      totalCount: "totalCount",
      overscan: "overscan",
      itemContent: "itemContent",
      components: "components",
      computeItemKey: "computeItemKey",
      data: "data",
      initialItemCount: "initialItemCount",
      scrollSeekConfiguration: "scrollSeekConfiguration",
      headerFooterTag: "headerFooterTag",
      listClassName: "listClassName",
      itemClassName: "itemClassName",
      useWindowScroll: "useWindowScroll",
      customScrollParent: "customScrollParent",
      scrollerRef: "scrollerRef",
      logLevel: "logLevel",
      restoreStateFrom: "restoreStateFrom",
      initialTopMostItemIndex: "initialTopMostItemIndex",
      increaseViewportBy: "increaseViewportBy"
    },
    methods: {
      scrollTo: "scrollTo",
      scrollBy: "scrollBy",
      scrollToIndex: "scrollToIndex"
    },
    events: {
      isScrolling: "isScrolling",
      endReached: "endReached",
      startReached: "startReached",
      rangeChanged: "rangeChanged",
      atBottomStateChange: "atBottomStateChange",
      atTopStateChange: "atTopStateChange",
      stateChanged: "stateChanged",
      readyStateChanged: "readyStateChanged"
    }
  },
  Mr
), Gr = /* @__PURE__ */ Ze({ useEmitter: no, useEmitterValue: et, usePublisher: It }), _r = /* @__PURE__ */ Xe({ useEmitter: no, useEmitterValue: et, usePublisher: It });
function Hn(t, e, n) {
  return e !== "normal" && !(e != null && e.endsWith("px")) && n(`${t} was not resolved to pixel value correctly`, e, mt.WARN), e === "normal" ? 0 : parseInt(e != null ? e : "0", 10);
}
const Yr = Wr;
export {
  jr as GroupedVirtuoso,
  mt as LogLevel,
  qr as TableVirtuoso,
  Kr as Virtuoso,
  Yr as VirtuosoGrid,
  qn as VirtuosoGridMockContext,
  be as VirtuosoMockContext
};
