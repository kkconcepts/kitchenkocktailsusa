import { validateApiPerspective } from "@sanity/client";
import { stegaEncodeSourceMap } from "@sanity/client/stega";
import { createNode, createNodeMachine } from "@sanity/comlink";
import { createCompatibilityActors } from "@sanity/presentation-comlink";
import { atom } from "./index.js";
const LISTEN_HEARTBEAT_INTERVAL = 1e4;
function enableLiveMode(options) {
  const { client, setFetcher, onConnect, onDisconnect, onPerspective } = options;
  if (!client)
    throw new Error(
      `Expected \`client\` to be an instance of SanityClient: ${JSON.stringify(client)}`
    );
  const { projectId, dataset, perspective } = client.config(), $perspective = atom(
    perspective && perspective !== "raw" ? perspective : "drafts"
  ), $connected = atom(!1), cache = /* @__PURE__ */ new Map(), comlink = createNode(
    {
      name: "loaders",
      connectTo: "presentation"
    },
    createNodeMachine().provide({
      actors: createCompatibilityActors()
    })
  );
  comlink.onStatus(() => {
    $connected.set(!0);
  }, "connected"), comlink.on("loader/perspective", (data) => {
    if (data.projectId === projectId && data.dataset === dataset) {
      validateApiPerspective(data.perspective);
      const nextPerspective = data.perspective === "raw" ? "drafts" : data.perspective;
      $perspective.set(nextPerspective), onPerspective?.(nextPerspective), updateLiveQueries();
    }
  }), comlink.on("loader/query-change", (data) => {
    if (data.projectId === projectId && data.dataset === dataset) {
      const { perspective: perspective2, query, params } = data;
      data.result !== void 0 && data.resultSourceMap !== void 0 && client.config().stega.enabled ? cache.set(JSON.stringify({ perspective: perspective2, query, params }), {
        ...data,
        result: stegaEncodeSourceMap(
          data.result,
          data.resultSourceMap,
          client.config().stega
        )
      }) : cache.set(JSON.stringify({ perspective: perspective2, query, params }), data), updateLiveQueries();
    }
  });
  let unsetFetcher;
  const unlistenConnection = $connected.listen((connected) => {
    connected ? (unsetFetcher = setFetcher({
      hydrate: (query, params, initial) => {
        const perspective2 = initial?.perspective || $perspective.get(), key = JSON.stringify({
          perspective: perspective2,
          query,
          params
        }), snapshot = cache.get(key);
        return snapshot?.result !== void 0 && snapshot?.resultSourceMap !== void 0 ? {
          loading: !1,
          error: void 0,
          data: snapshot.result,
          sourceMap: snapshot.resultSourceMap,
          perspective: perspective2
        } : {
          loading: $connected.value === !0 && initial?.data === void 0 || initial?.sourceMap === void 0,
          error: void 0,
          data: initial?.data,
          sourceMap: initial?.sourceMap,
          perspective: initial?.perspective || "published"
        };
      },
      fetch: (query, params, $fetch, controller) => {
        try {
          const removeLiveQuery = addLiveQuery(query, params, $fetch);
          if (controller.signal.addEventListener(
            "abort",
            () => {
              removeLiveQuery(), updateLiveQueries();
            },
            {
              once: !0
            }
          ), updateLiveQueries(), $fetch.setKey("error", void 0), controller.signal.aborted) return;
        } catch (error) {
          $fetch.setKey("error", error), $fetch.setKey("loading", !1);
        }
      }
    }), onConnect?.()) : (unsetFetcher?.(), onDisconnect?.());
  }), liveQueries = /* @__PURE__ */ new Set(), addLiveQuery = (query, params, $fetch) => {
    const liveQuery = { query, params, $fetch };
    liveQueries.add(liveQuery), emitQueryListen();
    const interval = setInterval(() => emitQueryListen(!0), LISTEN_HEARTBEAT_INTERVAL);
    return () => {
      clearInterval(interval), liveQueries.delete(liveQuery), emitQueryListen();
    };
  }, emitQueryListen = (skipSetLoading) => {
    if (!comlink)
      throw new Error("No connection");
    const perspective2 = $perspective.get();
    for (const { query, params, $fetch } of liveQueries)
      comlink.post("loader/query-listen", {
        projectId,
        dataset,
        perspective: perspective2,
        query,
        params,
        heartbeat: LISTEN_HEARTBEAT_INTERVAL
      }), !skipSetLoading && $connected.value === !0 && $fetch.setKey("loading", !0), $fetch.setKey("perspective", perspective2);
  };
  function updateLiveQueries() {
    const perspective2 = $perspective.get(), documentsOnPage = [];
    for (const { query, params, $fetch } of liveQueries) {
      const key = JSON.stringify({ perspective: perspective2, query, params }), value = cache.get(key);
      value && ($fetch.set({
        data: value.result,
        error: void 0,
        loading: !1,
        perspective: perspective2,
        sourceMap: value.resultSourceMap
      }), documentsOnPage.push(...value.resultSourceMap?.documents ?? []));
    }
    comlink.post("loader/documents", {
      projectId,
      dataset,
      perspective: perspective2,
      documents: documentsOnPage
    });
  }
  const stop = comlink.start();
  return () => {
    unsetFetcher?.(), unlistenConnection(), stop(), $connected.set(!1);
  };
}
export {
  enableLiveMode
};
//# sourceMappingURL=enableLiveMode.js.map
