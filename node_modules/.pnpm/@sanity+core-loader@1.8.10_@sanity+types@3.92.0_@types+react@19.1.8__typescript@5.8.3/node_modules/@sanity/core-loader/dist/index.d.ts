import type {ClientPerspective, ContentSourceMap, QueryParams, SanityClient} from '@sanity/client'
import type {StudioPathLike} from '@sanity/client/csm'
import type {SanityStegaClient, StegaConfig} from '@sanity/client/stega'
import {Redis} from 'ioredis'

declare type AllKeys<T> = T extends any ? keyof T : never

declare class Cache_2 {
  constructor(
    options: {
      ttl: number | ((result: unknown) => number)
      stale?: number | ((result: unknown) => number)
      storage: StorageInterface
    } & Events,
  )

  define<T extends (args: any) => any, N extends string, S extends this>(
    name: N,
    opts: {
      storage?: StorageOptions
      transformer?: DataTransformer
      ttl?: number | ((result: Awaited<ReturnType<T>>) => number)
      stale?: number | ((result: Awaited<ReturnType<T>>) => number)
      serialize?: (...args: any[]) => any
      references?: (
        args: Parameters<T>[0],
        key: string,
        result: Awaited<ReturnType<T>>,
      ) => References | Promise<References>
    } & Events,
    func?: T,
  ): S & {[n in N]: T}
  define<T extends (args: any) => any, N extends string, S extends this>(
    name: N,
    opts: T,
  ): S & {[n in N]: T}

  clear(): Promise<void>
  clear(name: string): Promise<void>
  clear(name: string, value: any): Promise<void>

  get(name: string, key: string): Promise<any>

  set(name: string, key: string, value: any, ttl: number, references?: References): Promise<void>

  invalidate(name: string, references: References): Promise<void>

  invalidateAll(references: References, storage?: StorageOptionsType): Promise<void>
}

export {ContentSourceMap}

/** @public */
export declare const createQueryStore: (options: CreateQueryStoreOptions) => QueryStore

/** @public */
export declare interface CreateQueryStoreOptions {
  /**
   * The Sanity client to use for fetching data, or `false` if `ssr: true` and it's set with `setServerClient` later
   * You may use any client that is an `instanceof SanityClient` or `instanceof SanityStegaClient`.
   * @example `import {createClient} from '@sanity/client'`
   * @example `import {createClient} from '@sanity/client/stega'`
   * @example `import {createClient} from '@sanity/preview-kit/client'`
   * @example `import {createClient} from 'next-sanity'`
   */
  client: SanityClient | SanityStegaClient | false
  /**
   * If you want all data fetching to be done server-side in production, set this to `true` and `client: false`.
   * Then, in your server entry file, you can set the Sanity client with `setServerClient`.
   */
  ssr?: boolean
  /** @internal */
  tag?: string
}

declare interface DataTransformer {
  serialize: (data: any) => any
  deserialize: (data: any) => any
}

/** @public */
export declare type EnableLiveMode = (options: EnableLiveModeOptions) => () => void

/** @public */
export declare interface EnableLiveModeOptions {
  /**
   * @deprecated -- no longer needed
   */
  allowStudioOrigin?: 'same-origin' | `https://${string}` | `http://${string}` | string
  /**
   * You may use any client that is an `instanceof SanityClient` or `instanceof SanityStegaClient`.
   * Required when `ssr: true`, optional otherwise.
   * @example `import {createClient} from '@sanity/client'`
   * @example `import {createClient} from '@sanity/client/stega'`
   * @example `import {createClient} from '@sanity/preview-kit/client'`
   * @example `import {createClient} from 'next-sanity'`
   */
  client?: SanityClient | SanityStegaClient
  /**
   * Fires when a connection is established to a parent Studio window.
   */
  onConnect?: () => void
  /**
   * Fires when a connection is established to a parent Studio window and then lost.
   */
  onDisconnect?: () => void
  /**
   * Fires when the perspective changes in the Studio, allowing you to persist the change to a session cookie if needed
   */
  onPerspective?: (perspective: Exclude<ClientPerspective, 'raw'>) => void
}

/**
 * Creates a encoded payload suitable for passing to a `data-sanity` attribute, which are used by `@sanity/visual-editing`
 * @public
 */
export declare type EncodeDataAttribute<QueryResponseResult = unknown> = (
  result: QueryResponseResult,
  sourceMap: ContentSourceMap | undefined,
  studioUrl: Exclude<StegaConfig['studioUrl'], undefined> | undefined,
  path: StudioPathLike,
) => string | undefined

declare type Events = {
  onDedupe?: (key: string) => void
  onError?: (err: any) => void
  onHit?: (key: string) => void
  onMiss?: (key: string) => void
}

/** @internal */
export declare interface Fetcher {
  hydrate: <QueryResponseResult, QueryResponseError>(
    query: string,
    params: QueryParams,
    initial?: Pick<
      QueryStoreState<QueryResponseResult, QueryResponseError>,
      'data' | 'sourceMap' | 'perspective'
    >,
  ) => QueryStoreState<QueryResponseResult, QueryResponseError>
  fetch: <QueryResponseResult, QueryResponseError>(
    query: string,
    params: QueryParams,
    $fetch: MapStore<QueryStoreState<QueryResponseResult, QueryResponseError>>,
    controller: AbortController,
  ) => void
}

declare type Get<T, K extends KeyofBase> = Extract<T, {[K1 in K]: any}>[K]

declare type HasIndexSignature<T> = string extends keyof T ? true : false

declare type KeyofBase = keyof any

declare interface Logger {
  debug: (input: LoggerInput) => void
  warn: (input: LoggerInput) => void
  error: (input: LoggerInput) => void
}

declare interface LoggerInput {
  msg: string
  [key: string]: any
}

export declare interface MapStore<Value extends object = any> extends WritableAtom<Value> {
  /**
   * Subscribe to store changes.
   *
   * In contrast with {@link Store#subscribe} it do not call listener
   * immediately.
   *
   * @param listener Callback with store value and old value.
   * @param changedKey Key that was changed. Will present only if `setKey`
   *                   has been used to change a store.
   * @returns Function to remove listener.
   */
  listen(
    listener: (
      value: ReadonlyIfObject<Value>,
      oldValue: ReadonlyIfObject<Value>,
      changedKey: AllKeys<Value>,
    ) => void,
  ): () => void

  /**
   * Low-level method to notify listeners about changes in the store.
   *
   * Can cause unexpected behaviour when combined with frontend frameworks
   * that perform equality checks for values, such as React.
   */
  notify(oldValue?: ReadonlyIfObject<Value>, changedKey?: AllKeys<Value>): void

  /**
   * Change store value.
   *
   * ```js
   * $settings.set({ theme: 'dark' })
   * ```
   *
   * Operation is atomic, subscribers will be notified once with the new value.
   * `changedKey` will be undefined
   *
   * @param newValue New store value.
   */
  set(newValue: Value): void

  /**
   * Change key in store value.
   *
   * ```js
   * $settings.setKey('theme', 'dark')
   * ```
   *
   * To delete key set `undefined`.
   *
   * ```js
   * $settings.setKey('theme', undefined)
   * ```
   *
   * @param key The key name.
   * @param value New value.
   */
  setKey<Key extends AllKeys<Value>>(
    key: Key,
    value: Get<Value, Key> | ValueWithUndefinedForIndexSignatures<Value, Key>,
  ): void

  /**
   * Subscribe to store changes and call listener immediately.
   *
   * ```
   * import { $router } from '../store'
   *
   * $router.subscribe(page => {
   *   console.log(page)
   * })
   * ```
   *
   * @param listener Callback with store value and old value.
   * @param changedKey Key that was changed. Will present only
   *                   if `setKey` has been used to change a store.
   * @returns Function to remove listener.
   */
  subscribe(
    listener: (
      value: ReadonlyIfObject<Value>,
      oldValue: ReadonlyIfObject<Value> | undefined,
      changedKey: AllKeys<Value> | undefined,
    ) => void,
  ): () => void
}

declare type Primitive = boolean | number | string

export {QueryParams}

/** @public */
export declare interface QueryStore {
  createFetcherStore: <QueryResponseResult = unknown, QueryResponseError = unknown>(
    query: string,
    params?: QueryParams,
    /**
     * Initial `data` and `sourceMap`, used with SSR hydration and is required if `ssr: true`
     * and an optional speed optimization if `ssr: false`
     */
    initial?: {
      data: QueryResponseResult
      sourceMap?: ContentSourceMap
      perspective?: ClientPerspective
    },
  ) => MapStore<QueryStoreState<QueryResponseResult, QueryResponseError>>
  /**
   * When `ssr: true` you call this in your server entry point that imports the result of `createQueryStore` instance.
   * It's required to call it before any data fetching is done.
   */
  setServerClient: (client: SanityClient | SanityStegaClient) => void
  enableLiveMode: EnableLiveMode
  /** @internal */
  unstable__cache: {
    instance: Cache_2 & {
      fetch: <QueryResponseResult>(key: string) => Promise<{
        result: QueryResponseResult
        resultSourceMap: ContentSourceMap | undefined
      }>
    }
  }
  /** @internal */
  unstable__serverClient: {
    /**
     * Only set if `ssr: true` and `setServerClient` has been called.
     */
    instance: SanityClient | undefined
    /**
     * Will be `true` if the client given to `setServerClient` has a token configured.
     */
    canPreviewDrafts?: boolean
  }
}

/** @public */
export declare interface QueryStoreState<QueryResponseResult, QueryResponseError> {
  loading: boolean
  error?: QueryResponseError
  data?: QueryResponseResult
  sourceMap?: ContentSourceMap
  perspective?: ClientPerspective
}

/**
 * Store object.
 */
declare interface ReadableAtom<Value = any> {
  /**
   * Get store value.
   *
   * In contrast with {@link ReadableAtom#value} this value will be always
   * initialized even if store had no listeners.
   *
   * ```js
   * $store.get()
   * ```
   *
   * @returns Store value.
   */
  get(): Value

  /**
   * Listeners count.
   */
  readonly lc: number

  /**
   * Subscribe to store changes.
   *
   * In contrast with {@link Store#subscribe} it do not call listener
   * immediately.
   *
   * @param listener Callback with store value and old value.
   * @returns Function to remove listener.
   */
  listen(
    listener: (value: ReadonlyIfObject<Value>, oldValue: ReadonlyIfObject<Value>) => void,
  ): () => void

  /**
   * Low-level method to notify listeners about changes in the store.
   *
   * Can cause unexpected behaviour when combined with frontend frameworks
   * that perform equality checks for values, such as React.
   */
  notify(oldValue?: ReadonlyIfObject<Value>): void

  /**
   * Unbind all listeners.
   */
  off(): void

  /**
   * Subscribe to store changes and call listener immediately.
   *
   * ```
   * import { $router } from '../store'
   *
   * $router.subscribe(page => {
   *   console.log(page)
   * })
   * ```
   *
   * @param listener Callback with store value and old value.
   * @returns Function to remove listener.
   */
  subscribe(
    listener: (value: ReadonlyIfObject<Value>, oldValue?: ReadonlyIfObject<Value>) => void,
  ): () => void

  /**
   * Low-level method to read store’s value without calling `onStart`.
   *
   * Try to use only {@link ReadableAtom#get}.
   * Without subscribers, value can be undefined.
   */
  readonly value: undefined | Value
}

declare type ReadonlyIfObject<Value> = Value extends undefined
  ? Value
  : Value extends (...args: any) => any
    ? Value
    : Value extends Primitive
      ? Value
      : Value extends object
        ? Readonly<Value>
        : Value

declare type References = string | string[]

/** @internal */
export declare const runtime: string

/** @internal */
export declare type SetFetcher = (fetcher: Fetcher) => () => void

declare class StorageInterface {
  constructor(options: any)

  get(key: string): Promise<undefined | any>
  set(key: string, value: any, ttl: number, references?: References): Promise<void>
  remove(key: string): Promise<void>
  invalidate(references: References): Promise<void>
  clear(name: string): Promise<void>
  refresh(): Promise<void>
}

declare interface StorageMemoryOptions {
  size?: number
  log?: Logger
  invalidation?: boolean
}

declare type StorageOptions = {
  type: StorageOptionsType
  options: StorageRedisOptions | StorageMemoryOptions
}

declare type StorageOptionsType = 'redis' | 'memory'

declare interface StorageRedisOptions {
  client: Redis
  log?: Logger
  invalidation?: {referencesTTL: number} | boolean
}

declare type ValueWithUndefinedForIndexSignatures<Value, Key extends keyof Value> =
  HasIndexSignature<Value> extends true ? undefined | Value[Key] : Value[Key]

/**
 * Store with a way to manually change the value.
 */
export declare interface WritableAtom<Value = any> extends ReadableAtom<Value> {
  /**
   * Change store value.
   *
   * ```js
   * $router.set({ path: location.pathname, page: parse(location.pathname) })
   * ```
   *
   * @param newValue New store value.
   */
  set(newValue: Value): void
}

export {}
