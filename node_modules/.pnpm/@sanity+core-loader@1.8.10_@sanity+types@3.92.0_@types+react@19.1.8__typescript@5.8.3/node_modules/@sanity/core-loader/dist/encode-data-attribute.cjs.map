{"version":3,"file":"encode-data-attribute.cjs","sources":["../src/encodeDataAttribute.ts"],"sourcesContent":["import {\n  jsonPathToStudioPath,\n  resolveEditInfo,\n  studioPath,\n  studioPathToJsonPath,\n  type ContentSourceMap,\n  type StudioPathLike,\n} from '@sanity/client/csm'\nimport type {StegaConfig} from '@sanity/client/stega'\nimport {encodeSanityNodeData} from '@sanity/visual-editing-csm'\nimport type {EncodeDataAttribute} from './types'\n\n/** @public */\nexport const encodeDataAttribute: EncodeDataAttribute<unknown> = (\n  result,\n  sourceMap,\n  studioUrl,\n  studioPathLike,\n) => {\n  if (!sourceMap || !studioUrl) {\n    return undefined\n  }\n  const resultPath = studioPathToJsonPath(studioPathLike)\n\n  const editInfo = resolveEditInfo({\n    resultPath,\n    resultSourceMap: sourceMap,\n    studioUrl,\n  })\n  if (!editInfo) {\n    return undefined\n  }\n\n  return encodeSanityNodeData({\n    baseUrl: editInfo.baseUrl,\n    workspace: editInfo.workspace,\n    tool: editInfo.tool,\n    type: editInfo.type,\n    id: editInfo.id,\n    path:\n      typeof editInfo.path === 'string'\n        ? editInfo.path\n        : studioPath.toString(jsonPathToStudioPath(editInfo.path)),\n  })\n}\n\nexport type {EncodeDataAttribute}\n\n/**\n * @public\n */\nexport type EncodeDataAttributeFunction = {\n  (path: StudioPathLike): string | undefined\n  scope: (path: StudioPathLike) => EncodeDataAttributeFunction\n}\n\n/**\n * @public\n */\nexport function defineEncodeDataAttribute<QueryResponseResult = unknown>(\n  result: QueryResponseResult,\n  sourceMap: ContentSourceMap | undefined,\n  studioUrl: Exclude<StegaConfig['studioUrl'], undefined> | undefined,\n  basePath?: StudioPathLike,\n): EncodeDataAttributeFunction {\n  const parse = (path?: StudioPathLike) => {\n    if (!path) return []\n    return typeof path === 'string' ? studioPath.fromString(path) : path\n  }\n\n  const parsedBasePath = parse(basePath)\n\n  // This function should encode the given attribute based on the result, sourceMap, and studioUrl\n  return Object.assign(\n    (path: StudioPathLike) =>\n      encodeDataAttribute(result, sourceMap, studioUrl, [...parsedBasePath, ...parse(path)]),\n    // The scope method creates a scoped version of encodeDataAttribute\n    {\n      scope: (scope: StudioPathLike) =>\n        defineEncodeDataAttribute(result, sourceMap, studioUrl, [\n          ...parsedBasePath,\n          ...parse(scope),\n        ]),\n    },\n  )\n}\n"],"names":["studioPathToJsonPath","resolveEditInfo","encodeSanityNodeData","studioPath","jsonPathToStudioPath"],"mappings":";;;AAaO,MAAM,sBAAoD,CAC/D,QACA,WACA,WACA,mBACG;AACC,MAAA,CAAC,aAAa,CAAC;AACjB;AAEF,QAAM,aAAaA,IAAA,qBAAqB,cAAc,GAEhD,WAAWC,IAAAA,gBAAgB;AAAA,IAC/B;AAAA,IACA,iBAAiB;AAAA,IACjB;AAAA,EAAA,CACD;AACI,MAAA;AAIL,WAAOC,sCAAqB;AAAA,MAC1B,SAAS,SAAS;AAAA,MAClB,WAAW,SAAS;AAAA,MACpB,MAAM,SAAS;AAAA,MACf,MAAM,SAAS;AAAA,MACf,IAAI,SAAS;AAAA,MACb,MACE,OAAO,SAAS,QAAS,WACrB,SAAS,OACTC,IAAAA,WAAW,SAASC,yBAAqB,SAAS,IAAI,CAAC;AAAA,IAAA,CAC9D;AACH;AAeO,SAAS,0BACd,QACA,WACA,WACA,UAC6B;AAC7B,QAAM,QAAQ,CAAC,SACR,OACE,OAAO,QAAS,WAAWD,IAAAA,WAAW,WAAW,IAAI,IAAI,OAD9C,CAId,GAAA,iBAAiB,MAAM,QAAQ;AAGrC,SAAO,OAAO;AAAA,IACZ,CAAC,SACC,oBAAoB,QAAQ,WAAW,WAAW,CAAC,GAAG,gBAAgB,GAAG,MAAM,IAAI,CAAC,CAAC;AAAA;AAAA,IAEvF;AAAA,MACE,OAAO,CAAC,UACN,0BAA0B,QAAQ,WAAW,WAAW;AAAA,QACtD,GAAG;AAAA,QACH,GAAG,MAAM,KAAK;AAAA,MACf,CAAA;AAAA,IAAA;AAAA,EAEP;AACF;;;"}